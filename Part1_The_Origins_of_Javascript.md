# Part 1: Javascript의 기원

## 2. Javascript 이전 시대(Prehistory)

월드 와이드 웹의 개념과 기반 기술들은 1989-1991년에 CERN의 팀 버너스 리[2003]에 의해 개발되었다. 버너스 리의 웹 기술은 몇 년 동안 고에너지 관련 물리학 커뮤니티에서 유포되었다. 하지만 그 커뮤니티 외부에서는 많은 주목을 받지 못했다. 이 상황은 1992-1993년에 당시 학부생이었던 Marc Andreessen과 일리노이 대학교 어바나-샴페인 국립 슈퍼컴퓨팅 응용 프로그램 센터(NCSA)에서 일하던 에릭 비나가 Mosaic$^{g}$를 개발하면서 변화하기 시작했다.

NCSA 모자이크는 GUI(graphic user interface)를 갖춘 설치하기 쉽고 사용하기 쉬운 웹 클라이언트였다. 이것은 사실상 '웹 브라우저'라는 소프트웨어 분류를 정의했고 물리학 커뮤니티 외부에서 월드 와이드 웹의 개념을 대중화했다. 모자이크는 널리 배포되었고 이런 브라우저 열풍에 편승하기 위해 NCSA 모자이크의 라이센스를 얻거나 모자이크에서 영감을 얻은 브라우저를 처음부터 만드는 데에 상업적 관심이 쏠렸다. 실리콘 그래픽스 주식회사(Silicon Graphics Inc.)의 창립자 Jim Clark는 벤처캐피탈 투자를 얻은 후 Marc Andreessen과 Eric Bina를 고용했다. 그리고 1994년 4월 그들은 나중에 Netscape Communications Corporation으로 불릴 회사를 공동 창립한다. 넷스케이프는 NCSA 모자이크를 대체하고 세계에서 가장 인기있는 브라우저가 되는 것을 목표로 삼았다. 넷스케이프는 개선된 차세대 모자이크-like 브라우저를 처음부터 개발했고 1994년 10월 널리 배포하기 시작했다. 1995년 초까지 Netscape Navigator$^{g}$는 초기 목표를 달성하고 모자이크를 빠르게 대체하고 있었다.

팀 버너스 리의 웹 기술은 선언적인($declarative^{g}$) HTML 마크업 언어를 사용하여 웹 페이지로 문서를 표시하는 데에 중점을 두었다. 반면 스크립트 언어($scripting language^{g}$)[Ousterhout 1997]를 사용하여 최종 사용자가 애플리케이션 동작을 조직할 수 있도록 하는 데에도 상당한 산업적인 관심이 있었다. 마이크로소프트 오피스의 비주얼 베이직, 애플스크립트[Cook 2007]과 같은 언어들은 주요 애플리케이션의 핵심을 구성하는 복잡한 자료구조와 알고리즘 컴포넌트들을 구현하기 위해 만들어진 게 아니었다. 대신 이런 언어들은 사용자들이 이런 애플리케이션 구성 요소들을 새로운 방식으로 결합할 수 있도록 했다. 넷스케이프가 월드 와이드 웹을 더 많은 사람들에게 보급함에 따라, 스크립팅 언어가 어떻게 웹 페이지에 통합되어야 하는지는 중요한 질문이 되었다.

## 2.1. 브랜든 아이크가 넷스케이프에 합류

브랜든 아이크[^4]는 1985년 일리노이 어바나-샴페인 대학교에서 석사 학위를 마치고 즉시 실리콘 그래픽스 주식회사에서 일을 시작했다. 그는 주로 유닉스 커널과 네트워크 계층 작업을 했다. 1992년에 그는 SGI를 떠나 비디오 미디어 프로세서를 개발하는 자금이 풍부한 스타트업 마이크로유니티에 합류했다. 두 회사에서 그는 커널과 네트워크 프로그래밍 작업을 지원하는 작은 특수목적 언어를 구현했다. 마이크로유니티에서는 GCC 컴파일러$^{g}$에 대한 작업도 조금 했다.

1995년 초 브랜든 아이크는 "와서 브라우저에 Scheme을 구현해라"[^5]라는 말을 미끼로 넷스케이프에 고용된다. 그러나 1995년 4월 3일 아이크가 넷스케이프에 합류했을 때 그는 복잡한 제품 마케팅과 프로그래밍 언어에 관련된 상황을 마주한다. 넷스케이프는 1994년 말 마이크로소프트의 저가 인수 제안을 거절한다. 그 후 넷스케이프 경영진은 마이크로소프트의 "Embrace, Extend, Extinguish"전략[Wikipedia 2019]에 직접적으로 공격받을 것으로 예상했다. 빌 게이츠의 직접적인 경영하에 있던 마이크로소프트는 웹이 크로스-OS 플랫폼으로 부상함에 따라서 그들이 곧 출시할 사적인 환경의 정보 유틸리티인 프로젝트 블랙버드[Anderson 2007]가 무의미해질 것을 빠르게 깨달았다. 빌 게이츠의 "인터넷의 해일"[Gates 1995]메모는 마이크로소프트를 프로젝트 블랙버드에서 인터넷 익스플로러$^{g}$와 서버 제품군 쪽으로 완전히 전환시켰다. 그 시점에 넷스케이프는 해당 시장을 점유하기 위해 서둘렀다.

웹 페이지의 스크립트 언어 후보로는 Scheme과 같은 연구용 언어와 Perl, Python, Tcl과 같은 실용적인 유닉스 기반 언어, 그리고 마이크로소프트의 비주얼 베이직과 같은 독점권이 있는 언어들이 있었다. 브랜든 아이크는 브라우저에 Scheme을 구현할 것으로 예상했다. 하지만 1995년 초 Sun Microsystems는 아직 출시되지 않은[^6] Java 언어에 대한 기습적인 홍보 캠페인[Byous 1998]을 시작했다. Sun과 넷스케이프는 빠르게 협력하여 Java를 넷스케이프 2에 통합하는 계약을 체결했다. 아이크는 넷스케이프 회의에서 Marc Andreessen이 "넷스케이프에 자바가 더해지면 윈도우즈를 죽인다"라는 슬로건을 말했던 것을 회상했다. 1995년 5월 23일 Sun이 Java를 공개한 날, 넷스케이프는 브라우저에서 Sun의 Java 기술을 라이센스할 의도를 발표했다.[Netscape 1995a]

넷스케이프 내부에서는 스크립트 언어를 선택하기 위해 급박한 전략을 수립해야 했고 이런 상황 때문에 Scheme, Perl, Python, Tcl, 그리고 비주얼 베이직을 실행 불가능한 후보로 만들었다. 시장에 출시하기까지의 시간 고려 및 사업적 이해관계로 인해서였다. 넷스케이프와 선의 고위 관리자들, 특히 Marc Andreessen과 선의 Bill Joy는 자바를 보완하는 "작은 언어"[^7]를 설계하고 구현하는 것만이 가능하다고 생각했다.

선과 넷스케이프의 주류에 해당하는 사람들은 간단한 스크립트 언어의 필요성에 대해 의문을 제기했다. Java는 스크립팅에 적합하지 않은가? 하나의 언어만 있는 것보다 왜 2개의 언어가 있는 게 나은지 설명 가능한가? 그리고 넷스케이프가 새로운 언어를 만들 만큼의 충분한 전문성을 갖추고 있는가?

첫 번째 반대는 쉽게 반박되었다. 1995년 봄 당시 Java는 초보자에게 적합한 언어가 아니었다. 메인 프로그램의 코드 본문은 패키지의 클래스^g 선언 내부의 `main`이라는 정적 메서드$^{g}$내에 있어야 했다. 모든 매개변수, 리턴값 그리고 변수에는 정적 타입$^{g}$을 선언해 주어야 했다. 비주얼 C++을 보완하는 비주얼 베이직, 그리고 네이티브 코드 기반의 컴포넌트를 보완하는 여러 유닉스 언어의 경험을 기반으로, Java가 스크립트 언어를 조립하는 `"glue" scripter`들에게 적합한 쉬운 언어가 아님은 명백했다.

두번째 반대는 마이크로소프트의 제품을 인용하는 것으로 극복할 수 있었다. 마이크로소프트는 전문 윈도우 애플리케이션 프로그래머들에게 비주얼 C++을 판매했다. 그리고 아마추어와 파트타임 프로그래머, 디자이너, 회계사 등에게는 비주얼 베이직을 판매했다. 비주얼 C++로 만들어진 컴포넌트들을 덜 숙련된 사람들이 조립하고 조작할 수 있는 스크립트 언어로서였다. "애플리케이션을 위한 비주얼 베이직"이라고 불린 비주얼 베이직 버전은 마이크로소프트 오피스 제품에 통합되어 그 제품들의 사용자 확장과 스크립팅을 지원했다.

처음의 두 가지 반대를 극복한 후 Marc Andreessen은 브라우저의 스크립트 언어의 코드네임으로 "모카(Mocha)"를 제안했다. 아이크에 의하면 이때 언어의 이름을 적절한 때 "Javascript"로 바꾸게 될 거라는 바람이 있었다고 한다. 아무튼 이 Java의 동반자 언어는 "자바처럼 보여야"했고 그럼에도 사용하기 쉬워야 했으며 Java같은 클래스 기반이 아닌 "객체 기반(object-based)"이어야 했다.

아직 마지막 하나의 반대 주장이 남아 있었다. 넷스케이프가 효율적인 스크립트 언어를 만들고 1995년 9월의 넷스케이프 2 베타에 맞게 준비할 수 있을 만큼 충분한 전문성을 갖추고 있는가? 모카를 만드는 것으로 이걸 증명하는 것이 브랜든 아이크의 과제였다.

[^4]: 아이크의 초기 커리어에 대해서는 Coders At Work[Seibel 2009, chapter 4]라는 책이 더 자세히 다루고 있다.
[^5]: Scheme 언어에 대한 언급[Sussman and Steele Jr 1975]
[^6]: Java의 스텔스 알파 릴리즈는 1995년 3월/4월이었다.
[^7]: 존 벤틀리[1986]은 작고 배우기 쉬운 언어를 묘사하기 위한 용어 "little language"를 다음과 같은 의미로 소개했다. "특정 문제 도메인에 특화되어 있으며 전통적인 언어들에서 발견되는 많은 특징들을 포함하지 않는 언어"

## 2.2. 모카의 이야기

Java의 발표가 임박한 상황에서 브랜든 아이크는 시간이 가장 중요하다고 보았다. 그리고 불확실한 가능성보다는 확실하게 보이는 것을 선택하여 1995년 5월의 10일 동안 최초의 모카$^{g}$ 구현을 시제품으로 만들었다.[^8] 이 작업은 실행 가능성을 보여주기 위한 기한에 맞추려고 서둘러 진행되었다. 데모는 최소한의 언어 구현으로 구성되었으며 넷스케이프 2 프리-알파 브라우저에 최소한으로 통합되었다. 

아이크가 만든 프로토타입은 실리콘 그래픽스 인디 유닉스 워크스테이션에서 개발되었다[Netfreak 2019]. 그 프로토타입은 수작업으로 만들어진 렉서와 재귀-하강(recursive-descent) 파서를 사용했다. 파서는 parse tree 대신 바이트코드로 변환된 명령어들을 출력했다. 바이트코드 인터프리터$^{g}$는 간단하고 느렸다.[^9]

바이트코드는 넷스케이프의 LiveWire 서버[^10] 쪽의 요구사항이었다. 그쪽의 개발자들은 모카가 프로토타입이 만들어지기도 전부터 그걸 내장할 것을 기대하고 있었다. 그 팀에 있는 볼랜드의 전 경영진과 엔지니어링 스태프들은 동적인 스크립트 언어의 강력한 지지자였지만, 더 빠른 서버 애플리케이션 로딩을 위해서 소스 파싱보다는 바이트코드를 원했다.

마크 앤드리슨은 모카가 누구든지 HTML 문서 내에서 몇 줄은 바로 쓸 수 있을 정도로 사용하기 쉬워야 한다고 강조했다. 선과 넷스케이프의 고위 관리직들은 모카가 "자바처럼 보여야 한다"고 되풀이해 요구했으며 BASIC과 같은 것을 명백히 배제했다. 하지만 자바처럼 보이는 외관을 가지는 것은 자바와 비슷하게 동작하리라는 기대를 만들었고 이는 객체$^{g}$ 모델의 설계와 boolean, int, double, string과 같은 "원시 타입"의 의미에 영향을 미쳤다.

자바처럼 보이는 것을 제외하면 브랜든 아이크는 대부분의 언어 설계 사양을 자유롭게 선택할 수 있었다. 넷스케이프에 합류한 후 그는 HyperTalk [Apple Computer 1988], Logo [Papert 1980], Self [Ungar and Smith 1987]와 같은 사용하기 쉽고 교육적인 언어들을 탐구했다. 모카가 객체 기반이 되어야 한다는 것은 모두 동의했다. 하지만 클래스는 없어야 했다. 왜냐 하면 클래스를 지원하는 것은 너무 오래 걸릴 뿐더러 클래스를 지원한다면 이미 클래스 모델을 갖추고 있던 자바와 경쟁해야 하는 리스크가 생겼기 때문이다. Self에 대한 존경심으로 아이크는 위임(delegation$^{g}$)을 사용하고 프로토타입 링크를 하나만 갖는 동적 객체 모델을 사용하기로 결정했다. 그는 이것이 구현 시간을 절약할 것이라고 믿었다. 하지만 결국 모카 프로토타입에서는 시간이 없어서 그 방식을 넣을 수 없었다.

객체는 생성자 함수$^{g}$에 new 연산자를 적용하여 생성할 수 있었다. 기본 객체 생성자 함수인 Object는 다른 내장 객체들과 함께 환경에 내장되어 있었다. 각 객체는 0개 이상의 속성으로 구성된다. 각 속성$^{g}$은 이름(또는 property key)과 값으로 구성되며, 이때 값은 함수$^{g}$, 객체 또는 다른 내장 데이터 타입 중 하나일 수 있다. 속성은 아직 사용되지 않은 속성 키에 값을 할당함으로써 생성됩니다. 속성에 대한 접근 제한이나 할당 제한은 없다(역주 : private나 getter 같은 개념을 말하는 듯 하다). 생성자 함수는 초기 속성 집합을 제공할 수 있다. 객체 생성 후에도 추가 속성을 객체에 추가할 수 있다. 이러한 매우 동적인 접근 방식은 특히 LiveWire 팀에게 좋은 반응을 얻었다.

Scheme을 사용하는 매력은 사라졌지만 브랜든 아이크는 여전히 Lisp 스타일의 일급$^{g}$ 함수 개념에 매력을 느꼈다. 클래스가 없어서 메소드를 포함할 수는 없었지만 일급 함수는 Scheme에서 영감을 얻은 용법들을 구현할 수 있는 도구를 제공했다. 최상위 레벨 프로시저, 함수를 인수로 넘기기, 객체의 메소드 그리고 이벤트 핸들러 등이 그렇다. 시간이 부족해서 함수 표현식(람다 표현식$^{g}$이라고도 불린다)의 구현은 연기되었지만 문법에는 예약되어 있었다. 이벤트 핸들러와 객체 메소드는 자바(그리고 C++)에서 가져온 this 키워드를 사용하여 통합되었다. 이 this 키워드는 메소드로서 호출된 함수에 대한 컨텍스트 객체를 나타낸다.

프로토타입은 프로그램을 포함하고 있는 문자열을 파싱하고 실행할 수 있는 eval 함수를 지원했다. 이는 마크 앤드리슨과 초기 넷스케이프 엔지니어들과의 비공식적인 토론에서 동기를 얻은 것이었다.[^11] 여기에 담긴 직관은 동적으로 문자열을 프로그램으로 변환하는 이런 종류의 동적인 프로그래밍이 웹 브라우저와 서버의 몇몇 애플리케이션에서 중요할 거라는 생각이었다.[^12] 하지만 이렇게 eval을 지원하기로 한 결정은 즉각적인 결과를 가져왔다. 몇몇 사용 사례에서는 함수가 Java같은 toString 메서드를 통해서 문자열 형식으로 그 소스코드를 전달할 것을 요구했다. 아이크는 10일간의 스프린트[^13]동안 바이트코드 디컴파일러를 구현하기로 결정했다. 몇몇 필요한 아키텍처를 위해서 소스 코드의 기본 저장소나 보조 저장소에서 복구하는 건 너무 비용이 많이 들 것으로 보였기 때문이다. 이는 윈도우즈 3.1 개인용 컴퓨터에서 특히 그랬다. 이 컴퓨터는 인텔 8086 16비트 세그먼트 메모리 모델에 의해 제한되어 있었고 무제한 또는 큰 인메모리 구조를 위해 오버레이와 수동으로 관리되는 멀티-세그먼트 메모리가 필요했다.

열흘의 프로토타이핑 기간 이후 모카 프로토타입은 전체 넷스케이프 엔지니어링 스태프가 모인 회의에서 공개되었다(그림 2). 이는 성공적이었고 이 성공은 1995년 9월에 첫 베타 릴리즈가 예정되어 있던 넷스케이프 2가 더 완전하고 통합된 버전으로 나올 수 있을 거라는 과도한 낙관주의로 이어졌다. 그해 여름 브랜든 아이크는 모카와 브라우저를 더 완전히 통합하는 것에 주로 초점을 맞췄다. 그러기 위해서는 모카 프로그램이 웹 페이지와 상호 작용할 수 있도록 API를 설계하고 구현해야 했다. 동시에 언어의 프로토타입 구현을 상용 가능한 소프트웨어로 변환하고 초기의 내부 사용자들의 버그 리포트, 변경 제안, 기능 요청에 응답해야 했다.

열흘간 진행된 모카의 창조에 대한 더 많은 내용은 브랜든 아이크가 해당 시절을 이야기한 데에서 찾아볼 수 있다.[Eich 2008c, 2011d; JavaScript Jabber 2014; Walker 2018] 모카의 프로덕션 버전의 소스코드는 인터넷 아카이브에서 볼 수 있다.[Netscape 1997b] 제이미 자윈스키[1999]의 "the netscape dorm"은 그 시절의 넷스케이프에서 소프트웨어 개발자로 일하는 경험에 대한 동시대의 기록이다.


[^8]: 정확한 날짜에 대한 알려진 기록은 없지만 브랜든 아이크는 이것이 5월 6일에서 15일까지였다고 기억하고 있다.
[^9]: 데이터 값$^{g}$을 나타내기 위해서 큰 discriminated union$^{g}$을 사용했으며 메모리 관리에는 레퍼런스 카운팅 기법을 사용했다.
[^10]: 브랜든 아이크는 넷스케이프에서의 첫 달 동안 공식적으로 서버 그룹에서 일했다.
[^11]: 클라이언트와 서버 사이드 둘 모두에서 쓰일 수 있는 2개의 언어를 만든 General Magic에서 일했던 John Giannandrea를 포함한다.
[^12]: 문자열을 동적으로 프로그램으로 변환함으로써, 예를 들어 폼(form)의 부분적인 평가를 하거나 클라이언트에서 제공된 코드를 서버에서 실행하는 걸 지원하도록 할 수 있었다. 이는 Telescript [General Magic 1995] 에이전트와 비슷했다.
[^13]: 1995년의 개발자들은 "스프린트"라는 단어를 쓰지 않았다. 하지만 이 단어는 당시 아이크의 노력을 잘 형상화한다.

# 3. Javascript 1.0과 1.1

넷스케이프 커뮤니케이션즈 주식회사와 썬 마이크로시스템즈는 1995년 12월 4일 JavaScript를 공동 보도 자료를 통해 발표했다[Netscape and Sun 1995; Appendix F]. 보도 자료에서는 JavaScript를 "객체 스크립팅 언어"이며 동적으로 "자바 객체의 속성과 동작을 수정하는" 스크립트를 작성하는 데 사용될 거라고 설명했다. 이것은 "온라인 애플리케이션 개발을 쉽게 하기 위해 존재하는 '자바의 보완재'"으로서의 역할을 할 거라고 했다. 회사들은 자바와 자바스크립트의 유사성이 표면적으로만 비슷했음에도 불구하고 둘 간의 강한 브랜드 연결을 구축하려고 시도했다. 자바와 자바스크립트 간 이름의 유사성과 두 언어들이 밀접하게 관련되어 있다는 암시는 꾸준히 혼동의 원인이 되었다.

![그림 2. 모카 콘솔](./pictures/mocha-console.png)
그림 2. 모카 콘솔. 브랜든 아이크가 만든 모카의 초기 데모에는 SGI 유닉스 워크스테이션에서 실행된 넷스케이프 2 프리알파 버전에서 구동되는 "모카 콘솔" 기능이 있었다. 이 모카 콘솔은 이름 빼고는 본질적으로 바뀌지 않은 채로 넷스케이프 2의 정식 릴리즈에 포함되었다. 이는 윈도우 95에서 실행되는 넷스케이프 2.02의 화면 캡처다. 모카 콘솔은 mocha:를 브라우저 주소 바에 입력하는 것으로 활성화되었다. 정식 버전의 넷스케이프 2에서는 이게 javascript:로 바뀌었지만 mocha:도 여전히 작동했다. 콘솔을 활성화하면 브라우저에서 두 칸으로 이루어진 페이지가 열렸다. 아래 칸의 텍스트 박스에 입력된 모카 표현식은 위 칸의 컨텍스트에서 평가되고 실행되었다. 이 예시는 표현식이 계산된 값을 포함하는 팝업을 표시하기 위해서 내장 alert 함수가 호출되는 것을 보여준다. 원래의 데모 버전에서는 "Javascript Alert" 대신 "Mocha Alert"가 표시되었을 것이다.

---

자바스크립트는 "LiveScript"라는 이름으로 넷스케이프 네비게이트 2.0의 첫 베타 릴리즈의 일부로 들어가면서 1995년 9월 처음 대중에게 공개되었다[Netscape 1995b]. 이후 4번의 베타 릴리즈가 더 진행되었고 1996년 3월 자바스크립트 1.0을 지원하는 넷스케이프 네비게이터 2.0의 정식 버전이 출시되었다. 넷스케이프 엔터프라이즈 서버 2.0도 1996년 3월 [Netscape 1996f]에 출시되었으며, 자바스크립트 1.0을 LiveWire의 서버사이드 스크립팅 컴포넌트에 포함했다.

자바스크립트는 넷스케이프 네비게이터의 상대적으로 작은 기능 중 하나였다. 그래서 자바스크립트의 개발은 1995년 8월의 기능 동결이 요구되었던 네비게이터 2.0의 전체적인 일정에 의해 제약을 받았다. 자바스크립트 1.0의 기능 세트는 본질적으로 당시 8월의 모카 구현에서 작동하거나 거의 작동하는 것들을 골라낸 것이었다. 이 기능 세트는 구상되었던 언어 설계에 비해 불완전했고 아이크가 네비게이터 2.0 릴리즈 과정에서 초기 모카 구현의 버그들을 계속 수정했음에도 불구하고 많은 문제가 있는 버그와 엣지 케이스 동작들을 보였다. 자바스크립트 1.0 릴리즈 직전에 브랜든 아이크의 인터뷰[Shah 1996]를 보면 브랜든 아이크는 자바스크립트가 자바의 부속물이라는 공식 입장과 초기 릴리즈의 급박한 상황을 반복해 말했다.

---

BE(브랜든 아이크): 저는 자바스크립트가 다른 회사들에 의해서도 구현되기를 바랍니다. 저와 빌 조이가 만들고 있는 사양에 기반해서요. 저는 자바스크립트가 작은 언어로 남기를 바라지만 HTML 요소와 거기에 가하는 동작들 그리고 Java applet과 다른 컴포넌트들을 결합하기 위해 쓰이면서 웹에서 범용적으로 사용되기를 바랍니다.

BE: ...제가 아는 한 자바스크립트의 가장 흔한 사용처는 페이지를 조금 더 똑똑하고 생생하게 만드는 건데요. 예를 들어 링크를 클릭하면 그때의 시간에 따라 다른 URL$^{g}$로 간다든지 하는 거요.
...

BE: 자바스크립트는 대부분 저 혼자 만들었기 때문에 넷스케이프 2.0은 짜증나는 작은 버그들이 많이 포함되어 있을 것입니다. 하지만 터널의 끝에는 빛이 있겠죠. 저는 모든 큰 버그들에 대해서는 해결책을 찾았기를 바랍니다. 다른 개발자들과 버그와 그 해결책을 찾는 데에 많은 시간을 썼거든요. 
저는 2.1버전을 마무리하고 있는데요. 버그를 고치고 기능을 추가하고 모든 플랫폼에서 자바스크립트가 일관되게 동작하도록 노력하고 있습니다. 2.1이 언제 출시될지는 모르겠지만, 저희는 빠르게 작업하고 있기 때문에 내년 봄 전에는 출시될 거라고 내기라도 걸 수 있습니다.

---

자바스크립트 1.0 [Netscape 1996d]는 산술 연산, 문자열, 불린값, 일급 함수 그리고 객체 자료형을 지원하는 간단한 동적 타입$^{g}$ 언어였다. 문법적으로 보면 자바스크립트는 자바처럼 C 계열에 속했다. C에서 가져온 제어 흐름 문법과 C의 산술 연산자 대부분을 포함하는 표현식 구문을 가지고 있었다. 자바스크립트 1.0에는 작은 내장 함수 라이브러리도 있었다. 자바스크립트 1.0 소스 코드는 보통 HTML 파일에 직접 포함되었다. 하지만 내당 라이브러리에는 자바스크립트의 문자열에 담긴 자바스크립트 소스 코드를 파싱하고 평가할 수 있는 eval 함수도 포함되어 있었다. 자바스크립트 1.0은 매우 간결한 언어였다. 그림 3은 자바스크립트 1.0에 없었던 몇몇 문법들의 요약인데, 이는 현대 자바스크립트 프로그래머에게는 매우 놀라울 수도 있다.

1996년 초, 이후 1996년 8월 출시되어 넷스케이프 네비게이터 3.0이라 불릴 제품에 대한 작업이 "아틀라스" [Netscape 1996g]라는 코드네임 하에 시작되었다. 브랜든 아이크는 1995년 8월 네비게이터 2.0에서 미완성이거나 누락되었던 기능들에 대한 작업을 다시 시작할 수 있었다. 자바스크립트의 초기 정의와 개발은 네비게이터 3.0에 담긴 자바스크립트 1.1 [Netscape 1996a,e]이 출시됨으로써 완성되었다. 다음 섹션들은 자바스크립트 1.0/1.1 언어의 설계에 대한 개요를 제공한다.

## 3.1 자바스크립트 문법

JavaScript 1.0의 문법은 C언어의 문장 구문[ANSI X3 1989]과 AWK$^{g}$[Aho 등 1988]에서 영향을 받은 몇 가지 장식을 직접적인 기반으로 모델링되었다. 스크립트는 선언(declaration)과 문장(statement)의 연속이다. C와 달리 자바스크립트의 문장은 함수 내부에서만 발생해야 한다는 제한이 없다. JavaScript 1.0에서 스크립트의 소스 코드는 HTML 문서 내에 포함된 `<script></script>` 태그로 둘러싸여 있다.

C의 영향을 받은 JavaScript 1.0의 문장들에는 이런 것이 있다. 표현식, if 조건문, for과 while 반복문, 비순차적인 흐름 제어를 위한 break, continue, return 문, `{}`로 묶인 문장들을 하나의 문장처럼 사용할 수 있게 하는 문장 블록, if, for, while 문은 복합 문장이다[^14]. JavaScript 1.0은 C의 do-while 문, switch 문, 문장 레이블(statement label), goto 문을 포함하지 않았다.

Javascript 1.0은 C의 문법을 기본으로 했는데, 거기에 객체 자료형의 속성에 접근하기 위한 2가지 복합 문장을 새로 추가했다. AWK에서 영향을 받은 `for-in` 문은 객체의 속성 키$^{g}$를 반복한다. with[^15]문의 본문 내에서는 지정한 객체의 속성에 접근할 때 마치 해당 속성명이 선언된 변수인 것처럼 접근할 수 있다. 객체의 속성은 동적으로 추가될 수 있으므로(이후 버전에서는 삭제됨) `with`문의 본문 내에서 코드 실행이 진행됨에 따라 보이는 변수 바인딩$^{g}$이 바뀔 수 있다.

Javascript의 선언은 C나 Java의 선언 스타일을 따르지 않는다. Javascript는 동적 타입 언어이다. 그리고 선언임을 인식하기 위한 문법적 접두사로 사용할 수 있는 타입명도 지원하지 않는다. 대신 Javascript 선언은 키워드가 접두사로 붙는다. Javascript 1.0의 선언에는 2가지 형태의 선언이 있는데 `function` 선언과 `var`선언이다. `function` 선언[^16] 문법은 AWK에서 직접적으로 가져왔다. `function`선언은 호출 가능한 단일 함수를 정의하는데, 이름, 형식 매개변수, 그리고 함수 본문을 정의한다. `var`선언은 하나 이상의 변수 바인딩을 도입하고 변수에 값을 할당할 수 있다. 값 할당은 필수는 아니다. 모든 var 선언은 문장으로 취급되며 블록 문장 내를 포함하는 어떤 문장 맥락에서도 발생할 수 있다. Javascript 1.0/1.1에서 `function`으로 시작되는 함수 선언은 스크립트의 최상위에서만 발생할 수 있으며 중첩된 함수 선언을 포함할 수 없었다. var 선언은 함수 본문 내에서 발생할 수 있으며, 이러한 선언으로 정의된 변수는 함수의 지역 변수이다.

C와 달리 Javascript 1.0에서 문장 블록, 즉 중괄호로 구분되는 블록들은 선언 스코프를 만들지 않는다. 함수 본문을 구분짓는 중괄호 블록 내의 var 선언은 전체 함수 본문에서 지역 변수로 동작한다. 함수 외부의 블록에 있는 var 선언은 전역 스코프$^{g}$를 가진다. 범위 내에 function이나 var 선언이 없는 변수명에 할당할 경우 그 이름의 전역 변수가 암시적으로 생성된다. 이 동작은 이미 선언된 변수의 이름을 잘못 타이핑해도 에러가 뜨는 대신 조용히 새 변수가 생성되도록 하기 때문에 버그의 큰 요인이 되었다.

Javascript와 전통적인 C 문법의 주요한 차이 중 하나는 문장의 끝에 붙이는 세미콜론을 Javascript가 처리하는 방식이다. C는 세미콜론을 문장 종결에 필수로 취급하는데, Javascript는 세미콜론이 한 줄의 마지막 significant character일 때 문장 종결을 위한 세미콜론을 생략할 수 있도록 허용한다. 이 동작의 정확한 규칙은 Javascript 1.0 문서에 포함되어 있지 않았다. Netscape 2.0 핸드북은 여러 Javascript 문장 형태를 설명할 때 세미콜론을 제대로 보여주지 않았다. 그냥 이렇게만 썼다. "하나의 문장이 여러 줄에 걸쳐 있을 수 있다. 그리고 여러 문장이 하나의 줄에 있을 수 있는데 이럴 때 각 문장은 세미콜론으로 구분된다[Netscape 1996d]." 세미콜론을 쓰지 않는 코딩 스타일은 핸드북의 Javascript 코드 예제에서 사용된 표준이었다.

```js
var a, x, y
var r=10
with (Math) {
  a = PI * r * r
  x = r * cos(PI)
  y = r * sin(PI /2)
}
```

세미콜론 없이 Javascript 코드를 작성할 수 있는 건 자동 세미콜론 삽입(Automatic Semicolon Insertion, ASI)덕분이다. ASI는 Javascript 프로그래머들 사이에서 여전히 논쟁의 대상이다. 프로그래머들의 상당한 수가 여전히 세미콜론 없이 코드를 작성하는 스타일을 선호하며, 다른 프로그래머들은 ASI를 사용하지 않고 세미콜론을 붙이는 것을 선호한다.

## 3.2. 자료형과 표현식

JavaScript 1.0/1.1은 5가지 기본 데이터 타입이 있는 동적 타입 언어였다. 그 5가지 타입은 숫자, 문자열, 불린, 객체, 함수였다. 여기서 동적 타입이라 함은 런타임의 타입 정보가 변수같은 값 컨테이너가 아니라 각 데이터와 관련되어 있다는 것을 뜻한다. 런타임 타입 검사는 각 연산이 그것을 지원하는 데이터 값에만 적용되도록 한다.

불린, 문자열, 숫자는 변경 불가능한 값이다. 불린 타입은 true와 false라는 두 가지 값이 있다. 문자열 값은 8비트 문자 코드로 이루어진 변경 불가능한 시퀀스다. 유니코드는 지원되지 않는다. 숫자 타입은 IEEE 754 [IEEE 2008]의 double 정밀도의 64비트 부동소수점 값 전체로 구성되며, 전통적인 NaN 값만 예외다. 일부 연산은 부호 없는 32비트 정수와 부호가 있고 2의 보수 형식으로 나타나는 정수에 해당하는 숫자 값을 특별히 다룬다. Mocha는 내부적으로는 이런 정수값을 다르게 표현했지만 공식적으로는 하나의 숫자 자료형만 있었다.

Javascript 1.0에는 유용한 데이터 값이 없음을 나타내는 데 쓰이는 2가지 특별한 값이 있었다. 초기화되지 않은 변수는 특별한 값 undefined[^17]로 설정되었다. 프로그램이 객체의 존재하지 않는 속성 키에 액세스하려고 할 때도 이 값이 반환되었다. Javascript 1.0에서는 초기화되지 않은 변수를 선언하고 접근함으로써 undefined 값에 접근할 수 있었다. null 값은 객체가 있을 것으로 예상되는 맥락에서 "객체 없음"을 나타내기 위해 만들어졌다. 이는 Java의 null 값에 기반을 두고 있으며, Java로 구현된 객체와 Javascript의 통합을 용이하게 했다. 두 유사하지만 차이점도 많은 값의 존재는 Javascript의 역사 동안 많은 프로그래머들에게 혼란을 주었다. 주어진 상황에서 둘 중 어떤 것을 사용해야 할지 확신하지 못하는 프로그래머들이 많았다.

Javascript 1.0의 표현식 문법은 C에서 가져왔으며 거의 동일한 연산자와 연산자 우선순위 규칙을 가진다. 몇 가지 빠진 부분도 있기는 한데 C의 포인터와 타입 관련 연산자, 그리고 단항 + 연산자이다. 이항 + 연산자는 숫자 덧셈 연산과 문자열 연결 2가지로 오버로딩되어 있다. 시프트 연산자와 비트 논리 연산자는 부호 있는 32비트 2의 보수 형식 정수의 비트 레벨 인코딩에 작용한다. 필요한 경우 피연산자는 정수가 되도록 끝을 자르고 32비트 값으로 모듈로 연산된다. >> 연산자는 32비트 정수 값의 부호를 보존하는 오른쪽 시프트를 수행한다. 그리고 Javascript는 Java에서 가져온 >>> 연산자를 추가했다. 이 연산자는 부호 없는 오른쪽 시프트를 수행한다.

JavaScript 1.1에는 delete, typeof, void 연산자가 추가되었다. Javascript 1.1에서 delete 연산자는 변수나 객체 속성을 피연산자로 받아서 그 값을 null로 설정했다. typeof 연산자는 피연산자의 원시 타입을 식별하는 문자열을 반환했다. 가능한 값으로는 "undefined", "object", "function", "boolean", "string", "number" 그리고 호스트 정의 객체를 식별하기 위해 구현체에서 정의한 값이 있었다. 놀랍게도 typeof null은 "null"이 아니라 "object" 문자열을 반환한다. 이는 모든 값이 객체이고 null이 본질적으로 "객체 없음"을 나타내는 객체인 Java와 일관성이 있다고 할 수도 있다. 그러나 Java는 typeof 연산자와 같은 기능을 하는 무언가가 없으며 초기화되지 않은 변수의 기본값으로 null을 사용한다. 브랜든 아이크는 typeof null의 결과는 처음의 모카 구현에 있었던 leaky abstraction$^{g}$의 결과였다고 회상한다. null의 런타입 값은 객체 값의 사용된 내부적인 태그 값과 같은 태그 값을 갖도록 인코딩되었고, 따라서 내부 태그 값을 확인하던 typeof 연산자의 당시 구현은 어떤 특별한 검사 로직 없이 "object"를 반환했던 것이다. 이는 객체의 속성에 접근해서 그 값을 사용하기 전 해당 값이 실제로 객체인지 테스트하려고 했던 Javascript 프로그래머들에게 큰 불편을 주었다. typeof의 결과가 "object"인 것을 테스트하는 것만으로는 null을 제대로 걸러낼 수 없었고 null의 속성에 접근하려고 시도하는 것은 런타임 오류를 발생시켰기 때문이다.

void 연산자는 단순히 피연산자를 평가한 다음 undefined를 반환한다. undefined에 접근하는 하나의 일반적인 방법은 void 0을 사용하는 것이다. void 연산자는 원래 클릭했을 때 Javascript 코드를 실행하는 HTML 하이퍼링크를 정의하기 위해 도입되었다. 예를 들어 이런 식이다.

```html
<a href="javascript:void usefulFunction()">Click to do something useful</a>
```

href 속성$^{g}$의 값은 URL이어야 하는데 javascript:는 브라우저에 의해 인식되는 특별한 URL 프로토콜이다. 이는 뒤따르는 것을 JavaScript 코드로 평가하고, 그 결과를 문자열로 변환하여 일반 href URL을 사용하여 가져온 응답 문서인 것처럼 사용하라는 의미이다. `<a>` 요소는 그 응답 문서가 undefined가 아닌 경우 그것을 처리하려고 시도할 것이다. 그런데 일반적으로 웹 개발자는 링크가 클릭되었을 때 Javascript 표현식이 그냥 실행되고 평가되기만 원하지 그 결과를 사용하고 싶어하지는 않는다. void 연산자를 표현식 앞에 붙이는 것은 `<a>`요소에 의한 추가 처리를 방지하고 개발자가 원하는 대로 표현식이 평가만 되도록 해주었다.

![그림 4](./pictures/figure4.png)

그림 4. Eich와 McKinney에 의해 발표된 Javascript 1.1 타입 변환표[1996, page 23]. Javascript 1.1 예비 사양에 있었다. 최종적으로 표준화된 타입 변환 규칙은 약간 다르다. 이 그림은 약간의 인쇄상의 차이가 있지만 원본 표의 복사본이다. 원본에는 각주 3이 없었다.

C와 JavaScript 표현식 사이의 가장 중요한 차이점은 JavaScript 연산자는 자동으로 피연산자를 연산자가 받을 수 있는 자료형으로 암묵적 형변환을 한다는 것이다. Javascript 1.1은 이렇게 임의의 객체를 숫자나 문자열 값으로 변환하는 설정 가능한 메커니즘을 추가했다. 그림 4는 Javascript 1.1의 암묵적 형변환 규칙을 요약한다.

## 3.3. 객체(Objects)

```js
// using Object constructor
var pt = new Object;
pt.x=0;
pt.y=0;

// using custom constructor
function Point (x,y) {
this.x = x;
this.y = y;
}
var pt = new Point (0, 0);
```

그림 5. Javascript 1.0의 객체 생성을 위한 다른 방법들. Object 생성자로 객체를 생성한 뒤 속성을 추가할 수도 있고 생성자 함수를 만들어서 객체가 만들어지는 동안 속성을 추가할 수도 있다.
---
Javascript 1.0의 객체는 "속성(property)"라 불리는 원소들로 이루어진 연관 배열이다. 각 속성은 문자열로 된 키와 값을 가지고 값은 Javascript의 어떤 데이터 타입이든 될 수 있다. 속성은 동적으로 추가될 수 있다. JavaScript 1.0/1.1은 객체에서 속성을 제거하는 방법을 제공하지 않았다.

키 문자열이 식별자 이름에 대한 문법 규칙을 준수할 시 해당 속성은 점 표기법을 통해서 접근할 수 있다. 예를 들어서 `obj.prop0`과 같이 할 수 있다. 식별자가 아닌 키를 가진 속성을 포함한 모든 속성은 대괄호 표기법으로 접근할 수 있다. 이 표기법을 사용하면 대괄호로 둘러싸인 표현식은 평가되고 문자열로 변환되어 속성의 키로 사용된다. 예를 들어 obj["prop"+n]은 n의 값이 0일 때 obj.prop0과 동일하다. 존재하지 않는 속성에 값을 할당하면 새로운 속성이 생성된다. 만약 존재하지 않는 속성의 값에 접근하려고 하면 보통 undefined가 반환된다. 하지만 Javascript 1.0/1.1에서는 대괄호 표기법을 사용해 존재하지 않는 객체의 속성 값에 접근했으며 사용한 속성 키가 음이 아닌 정수의 문자열 표현이었을 경우 null이 반환되었다.

속성은 데이터 저장소로 사용될 수도 있고 객체의 동작을 구현하는 데에 사용될 수도 있다. 그 값이 함수인 속성은 객체의 메서드로서 호출될 수 있다. 객체의 메서드로 호출된 함수는 키워드 this와의 동적 바인딩을 통해 자신을 호출한 객체 그 자신에게 접근할 수 있다(§3.7.4).

객체는 내장 함수나 사용자 정의 함수에 new 연산자를 적용하여 생성된다. 이런 용도로 사용되기 위해 만들어진 함수를 "생성자(constructor)"라고 한다. 생성자는 일반적으로 새로운 객체에 속성을 추가한다. 이 속성들은 저장할 데이터 혹은 메서드이다. 내장 생성자 Object는 초기에 속성이 없는 새로운 객체를 생성하는 데에 사용될 수 있다. 그림 5는 Object 생성자나 사용자 정의 생성자 함수가 새로운 객체를 생성하는 방법을 보여준다.

JavaScript 1.0에는 또한 내장 Array 생성자가 있다. 하지만 Array 생성자로 생성된 객체와 Object 생성자로 생성된 객체 사이의 유일한 차이점은 객체에 표시되는 디버깅 문자열뿐이다. JavaScript 1.0의 Array 생성자로 생성된 객체는 length 속성을 가지고 있지 않았다.

정수값을 키로 사용하는 속성들을 생성함으로써 어떤 객체에 대해서든 배열과 유사한 인덱싱 동작을 할 수 있다. 이런 객체는 정수가 아닌 키를 가진 속성들도 가질 수 있다.

```js
var a = new Object; // or new Array
a[0] = " zero ";
a[1] = " one";
a[2] = " two";
a. length = 3;
```

---

```js
// define functions to be used as methods
function ptSum(pt2) {
    return new Point(this.x + pt2.x, this.y + pt2.y)
}

function ptDistance(pt2) {
    return Math.sqrt(Math.pow(pt2.x - this.x, 2) + Math.pow(pt2.y - this.y, 2));
}
// define Point constructor
function Point(x, y) {
    // create and initialize a new object 's data properties
    this.x = x;
    this.y = y;
    // add methods to each instance object
    this.sum = ptSum;
    this.distance = ptDistance;
}
var origin = new Point(0, 0); // create a Point object
```

그림 6. Javascript 1.0에서 추상화된 Point 객체를 생성한다. 각 인스턴스는 각각의 메서드 속성들을 가지고 있다.

---

Javascript 1.0은 상속$^{g}$의 개념이 없다. 프로그램은 각각의 새로운 객체에 모든 속성을 개별적으로 추가해야 한다. 이는 일반적으로 프로그램에서 사용하는 각 "클래스" 객체에 대한 생성자 함수를 정의하는 방식으로 이루어진다. 그림 6은 Javascript 1.0을 사용하여 작성된 간단한 Point 추상화 정의를 보여준다. 이 예제에서 중요한 점은 다음과 같다.

- 각 메서드는 전역 함수로 정의되어야 한다. 이 함수들은 다른 추상화 객체의 메서드 함수를 정의하는 데에 사용되는 이름과 충돌하지 않을 가능성이 있는 이름을 가져야 한다(예: ptSum, ptDistance).
- 객체가 생성되는 시점에 객체 속성들은 각 메서드를 위해 생성된 전역 함수로 초기화된 값으로 생성되어야 한다.
- 메서드는 선언된 전역 이름(ptDistance)보다는 객체 속성 이름(origin.distance)을 사용하여 호출된다.

Javascript 1.1에서는 각각의 새로운 인스턴스에 직접 메서드 속성을 생성할 필요가 없어졌다. 1.1부터는 생성자 함수 객체의 `prototype`이라는 속성을 통해서 생성자 함수 인스턴스의 프로토타입$^{g}$ 객체를 연결할 수 있게 되었다. JavaScript 1.1 가이드 [Netscape 1996e]는 `prototype`을 "지정된 타입의 모든 객체에 의해 공유되는 속성"으로 설명한다. 이건 모호한 설명이고, 다음과 같이 더 잘 표현할 수 있다. "해당 생성자에 의해 생성된 모든 객체에 의해 공유되는 속성을 가진 객체"라고 말이다. 이런 공유 메커니즘은 더 자세히 설명되지는 않았지만 다음과 같은 프로토타입 객체의 속성들을 관찰할 수 있다.

- 해당 객체를 생성한 생성자 함수의 `prototype` 객체에 정의된 속성 이름에 접근하면 생성자 함수의 `prototype` 객체의 해당 속성 값이 반환된다.
- 프로토타입 객체의 속성을 추가하거나 수정하는 것은 기존에 해당 prototype 속성을 가진 생성자 함수에 의해 만들어진 객체에 즉시 반영된다.
- 객체의 생성자 함수의 `prototype`에 이미 정의되어 있는 속성과 같은 이름의 속성에 값을 할당하면 객체의 속성 값이 생성자 함수의 `prototype`에 정의된 속성 값을 덮어씌운다(shadow$^{g}$[^18]).

내장 Object.prototype 객체의 속성은 객체 또는 객체의 프로토타입 객체에 의해 덮어씌워지지 않는 한 모든 객체에서 접근 가능하다.

[^18]: 프로토타입의 속성을 덮어씌우는(over-ride)새로운 속성을 만드는 것

```js
// define functions to be used as methods
function ptSum(pt2) {
    return new Point(this.x + pt2.x, this.y + pt2.y)
}

function ptDistance(pt2) {
    return Math.sqrt(Math.pow(pt2.x - this.x, 2) + Math.pow(pt2.y - this.y, 2));
}
// define Point constructor
function Point(x, y) {
    // create / initialize a new object's data properties
    this.x = x;
    this.y = y;
}
// add methods to shared prototype object
Point.prototype.sum = ptSum;
Point.prototype.distance = ptDistance;
var origin = new Point(0, 0); // create a Point object
```

그림 7. Javascript 1.1에서 추상화된 Point 객체를 생성한다. 각 Point 인스턴스 객체는 직접 속성들을 정의하는 대신 `Point.prototype` 객체에서 메서드 속성들을 상속받는다.

---

그림 7은 그림 6에서 했던 간단한 Point 추상화를 Javascript 1.1에서 다시 정의한 것이다. 이는 메서드가 각 인스턴스 객체에서 반복적으로 정의되는 것과 달리 프로토타입 객체에 한 번만 정의된다는 점이 다르다. 프로토타입 속성을 통해서 객체에서 접근할 수 있는 속성은 상속된 속성$^{g}$이라고 한다. 객체에 직접 정의된 속성은 자체 속성$^{g}$이라고 한다. 자체 속성은 동일한 이름의 자체 속성을 덮어씌운다.

프로토타입 객체 속성은 보통 메서드다. 이 경우 생성자를 통해 제공된 프로토타입 객체는 C++의 vtable이나 Smalltalk의 MethodDictionary와 같은 역할을 하여 객체들의 집합과 공통의 행동을 연관시킨다. 생성자 함수는 본질적으로 클래스 객체의 역할을 하고 프로토타입은 클래스 인스턴스들에게 공유되는 메서드들의 컨테이너와 같다. 이것은 Javascript 1.1의 객체 모델에 대한 합리적인 해석이지만 유일한 해석은 아니다.

생성자 함수의 `prototype` 이라는 속성의 작명은 브랜든 아이크가 다른 객체 모델을 염두에 두었다는 명백한 단서이다. 그 모델은 Self 프로그래밍 언어에 의해 영감을 받았다[Ungar and Smith 1987]. Self에서는 새로운 객체를 만들 때 일부 객체 카테고리의 프로토타입 객체를 복제하여 만든다. 각각의 복제본은 프로토타입 객체를 참조하는 부모 링크를 가지고 있어서 프로토타입이 그 복제본들에게 공통적으로 제공하고자 하는 기능들을 제공할 수 있었다. Javascript 1.1 객체 모델은 Self의 모델의 변형이라고 할 수 있다. 프로토타입 객체는 생성자 함수를 통해서 간접적으로 접근되고 new 연산자는 프로토타입에서 새로운 인스턴스를 복제한다. 복제된 인스턴스는 프로토타입 객체의 속성들을 상속$^{g}$받아서 공통 기능으로 사용할 수 있다. 일부 Javascript 프로그래머들은 이 메커니즘을 "프로토타입 상속$^{g}$"이라고 부른다. 이것은 위임의 한 형태이다. 일부 Javascript 프로그래머들은 Java와 다른 많은 객체지향 언어들에서 사용되는 상속 스타일을 가리키기 위해 "전통적인 상속(classical inheritance)$^{g}$"이라는 중의적 표현을 사용한다.

JavaScript 1.1 문서 [Netscape 1996e]는 이러한 객체 모델 중 어느 것도 완전히 설명하지 않는다. 그 문서는 1995년 12월 넷스케이프와 선의 보도자료와 일관성 있는 마케팅 전략을 유지했다. Javascript는 추상화된 진짜 객체 정의(클래스 정의)는 Java로 쓰여질 때 그 객체들 간의 상호작용을 위한 스크립트 언어로 포지셔닝되었다. Javascript 고유의 객체 추상화 기능은 별로 주목을 끌지 않고 잘 문서화되지 않은 보조 기능으로 제한되었다.

## 3.4. 함수 객체(Function Objects)

Javascript 1.0/1.1의 함수 정의는 호출 가능한 함수를 만들고 이름을 지정한다. Javascript의 함수는 일급 객체 값이다. `function` 키워드 선언에 주어진 이름은 최상위 스코프에서의 `var` 선언과 같이 전역 변수를 정의한다. 그 값은 함수 객체이며 변수에 할당되거나 그 값은 함수 객체이며 변수에 할당되거나, 속성 값으로 설정되거나, 함수 호출에서 인수로 전달되거나, 함수의 반환값으로 쓰일 수 있다. 함수는 객체이기 때문에 속성을 가질 수도 있다. 다음 예시는 함수 객체에 속성을 추가하는 방법을 보여준다.

```js
function countedHello() {
    alert("Hello , World !");
    countedHello.callCount++; // increment this function's callCount property
}

countedHello.callCount = 0; // associate counter with function and initialize
for (var i = 0; i < 5; i++) countedHello();
alert(countedHello.callCount); // displays : 5
```

함수는 형식 매개변수 목록과 함께 선언된다. 하지만 정의와 함께 선언된 매개변수 목록의 크기는 실제로 함수를 호출할 때 전달될 수 있는 인수의 갯수를 제한하지는 않는다. 만약 함수 정의에 선언된 형식 매개변수보다 적은 인수로 함수를 호출하면 전달되지 않은 매개변수는 undefined로 설정된다. 형식 매개변수보다 많은 인수로 함수를 호출하면 추가 인수는 평가되지만 그 값을 매개변수 이름을 통해서 사용할 수는 없다. 그러나 함수 본문이 실행되는 동안 함수 객체의 `arguments` 속성 값을 통해 인수들을 담은 유사 배열 객체를 사용할 수 있다. 함수 호출 시 전달된 모든 실제 인수는 `arguments` 객체의 정수 키 속성을 통해서 사용할 수 있다. 이를 통해 가변 갯수의 인수들을 처리할 수 있는 함수를 작성할 수 있다.

## 3.5. 내장 라이브러리(Built-in Library)

![그림 8](./pictures/figure8.png)

그림 8. Javascript 1.0/1.1의 호스트-독립적인 내장 라이브러리

---

JavaScript 1.0은 내장 함수, 객체, 생성자들의 라이브러리를 가지고 있었다. 이 라이브러리는 소수의 일반 목적 객체[^19]들과 함수들, 그리고 더 많은 호스트별 객체와 함수들을 정의한다. 넷스케이프 네비게이터의 경우 호스트 객체$^{g}$는 현재 HTML 문서의 일부 모델을 제공했다. 이 API들은 결국 '문서 객체 모델(Document Object Model, DOM) 레벨 0' [Koch 2003; Netscape 1996b]으로 알려지게 된다. 넷스케이프 엔터프라이즈 서버의 경우 호스트 객체는 클라이언트/서버 통신, 클라이언트와 서버 세션의 상태 관리, 파일 및 데이터베이스 접근을 지원했다. 서버 호스트 객체에 대한 이러한 설계는 넷스케이프 서버 제품 외에는 널리 채택되지 않았다.

Javascript의 초기 설계는 대부분 브라우저 플랫폼에서 필요로 하는 것들에 의해 주도되었다. 초기 Javascript 버전의 넷스케이프 문서는 어떤 라이브러리 요소가 호스트 환경에 의존적이고 어떤 라이브러리 요소가 호스트 환경에 독립적인지 명확히 구분하지 않았다. 그러나 DOM과 다른 브라우저 플랫폼 API의 설계, 진화, 표준화는 각각의 중요한 이야기를 가지며 그 자체로서의 역사를 가진다. 이 문서는 Javascript의 전체적인 설계와 관련되어 있을 경우에만 브라우저 관련 주제들을 언급한다.

Javascript 1.0은 딱 2가지의 일반 목적 객체 분류를 가지고 있었다. `String`과 `Date`였다. 그리고 일반적으로 사용되는 수학의 상수와 함수들을 정의한 싱글톤 전역 객체 Math도 있었다. 또 접근 방법을 알고 있을 경우 활성화되지 않았거나 불완전하게 구현된 여러 클래스의 생성자들도 Javascript 1.0 프로그램에서 접근할 수 있었다. Javascript 1.1은 이런 기능들의 구현을 완성하고 문서화했다. 그림 8은 Javascript 1.0과 1.1에서 정의된 호스트 독립적인 클래스들을 요약해 보여준다.

[^19]: Javascript에는 객체 추상화 메커니즘을 위한 공식적인 명명이 없었다. 그래서 Javascript 내장 라이브러리에서 지원하는 특정 종류의 객체에 대해 이야기하기 쉽지 않다. JavaScript 문서에서는 "타입", "객체", "생성자", "클래스"와 같은 다양한 용어로 이런 추상화 객체를 이야기했다. 이 문서의 나머지 부분에서는 공통된 표현과 메서드를 공유하는 Javascript 객체 집합을 부르기 위해 첫 글자가 대문자인 `Class`라는 용어를 사용하겠다. 이는 실제 객체 정의의 형태와는 관계없이 적용된다.

---

`String` 클래스는 `length` 속성과 6개의 일반 메서드를 제공한다. 이 메서드들은 불변의 문자열 값들에 작용하며 적절한 경우 새로운 문자열 값을 반환한다. JavaScript 1.0의 `String` 클래스는 또한 문자열 값을 다양한 HTML 태그로 감싸는 열세 개의 메서드를 포함gksek. 이는 Javascript 1.0/1.1에서 호스트 의존적 기능과 일반 목적 기능 사이의 유동적인 경계를 보여주는 예시이다. Javascript 1.0은 전역 `String` 생성자 함수를 제공하지 않는다. 모든 문자열 값은 문자열 리터럴이나 연산자 혹은 내장 함수를 통해서 생성된다. Javascript 1.1에서 전역 `String` 생성자와 `split` 메서드가 추가되었다.

`Date` 클래스는 달력 날짜와 시간을 나타내기 위해 쓰인다. Javascript 1.0의 `Date`는 Java 1.0의 `java.util.Date` 클래스를 버그까지도 그대로 옮긴 것이었다[Gosling et al. 1996]. 이는 1970년 1월 1일 GMT 00:00:00을 기준으로 시작하는 밀리세컨드 단위의 시간 값을 사용하는 것, 다른 날짜 관련 값들과 달리 월을 나타내는 값을 0-11로 번호매기는 것, 자바 설계에 있었던 2000년 문제 등을 포함한다. 이런 설계 결정은 Java와의 호환성 요구 사항에 영향을 받았다. Java의 `java.util.Date`를 옮겨올 때 빠진 것은 equals, before, after뿐이었다. 이들은 Javascript의 자동 형변환으로 인해 숫자 관계 연산자를 Date 객체에 직접 사용할 수 있었기 때문에 필요없어서 제외되었다.

Date는 Object를 제외하면 Javascript 1.0에서 유일하게 사용 가능한 내장 생성자 함수였다. Date는 또 클래스 인스턴스의 메서드 외에 생성자 객체에 메서드를 노출하는 유일한 클래스였다. 브라우저별 클래스 중 어떤 것도 생성자 함수를 노출하지 않았다.

내장 라이브러리 객체와 호스트 제공 객체의 일부 속성은 Javascript 프로그래머가 직접 정의한 속성(사용자 정의 속성)은 가질 수 없는 특징들을 가지고 있다. 예를 들어 내장 객체의 메서드 속성은 for-in 문에 의해 열거되지 않는다. 일부 속성은 delete 연산자를 써도 무시되거나 읽기 전용 값이다. 내장 객체의 일부 속성에 접근하거나 속성을 수정하는 것은 사이드 이펙트를 가진 특별한 동작을 유발한다.

JavaScript 1.1은 사용 가능한 Array 클래스를 추가했다. Array 생성자는 0에서 시작하는 정수 인덱스를 가지며 서로 다른 여러 종류의 값들로 이루어진 벡터와 같은 객체를 생성한다. 배열의 각 요소는 정수 인덱스의 문자열 표현(역주: `'0'`, `'1'`과 같은)을 키로 가지는 객체 속성으로 표현된다. 배열 객체는 또한 생성자에 의해 값이 초기화되는 `length` 프로퍼티를 가지고 있다. `length` 속성의 값은 현재 `length` 값보다 크거나 같은 요소 인덱스에 접근할 때마다 업데이트된다. 따라서 배열 객체의 요소 수는 동적으로 증가할 수 있다.

## 3.6. 실행 모델(Execution Model)

넷스케이프 2와 그 이후의 브라우저에서, HTML 웹 페이지는 여러 개의 `<script>` 요소를 포함할 수 있다. 페이지가 로드될 때 HTML 문서를 위한 새로운 Javascript 실행 환경과 전역 컨텍스트가 생성된다. 전역 컨텍스트에는 Javascript와 호스트 환경이 제공하는 내장 함수와 변수의 이름들을 키로 가지는 전역 객체가 포함되어 있다. 그리고 전역 객체에는 스크립트 코드에 의해 정의된 전역 변수와 함수들도 정의되어 있다.

넷스케이프 2에서 각 `<script>` 요소의 Javascript 코드는 페이지의 HTML 파일 내에서의 순서대로 구문 분석되고 평가된다. 최신 브라우저에서는 `<script>` 요소의 지연 평가를 위한 태그를 붙일 수 있다. 이 태그를 붙이면 Javascript 코드가 네트워크 통신 등 HTML 분석과 관계없는 코드를 실행할 경우 그동안 HTML 처리를 계속할 수 있다. 어떤 경우든 브라우저는 한번에 하나의 스크립트만 평가한다. 스크립트는 일반적으로 동일한 전역 객체를 공유한다. 하나의 스크립트에 의해 생성된 전역 변수와 함수는 이후의 모든 스크립트에서 볼 수 있다. 각 스크립트는 선점이나 중단 없이 완료될 때까지 실행된다. 이런 초기 브라우저의 특성은 자바스크립트의 근본적인 원칙이 되었다. 스크립트는 실행에 대한 원자 단위이며 한번 실행되면 완료될 때까지 실행된다. 스크립트 내에서는 다른 스크립트의 동시 실행으로 인한 간섭에 대해 걱정할 필요가 없다. 그런 일이 일어날 수 없기 때문이다.

넷스케이프 2는 또한 웹 페이지 프레임[^20]의 개념을 도입했다. 프레임은 별도의 HTML 문서가 로드될 수 있는 웹 페이지상의 영역이다. 페이지의 모든 프레임은 동일한 자바스크립트 실행 환경을 공유하지만, 각 프레임은 해당 환경 내에서 각각의 다른 전역 컨텍스트를 가진다. 다른 프레임에 로드된 스크립트는 다른 전역 객체, 다른 내장 요소, 그리고 다른 전역 변수와 함수를 가진다. 하지만 전역 컨텍스트는 주소 공간이 아니다. Javascript 실행 환경은 객체의 단일 주소 공간을 가지며 이는 그 환경 내의 모든 프레임 내에서 공유된다. 이런 단일 주소 공간 덕분에 다른 프레임의 Javascript 코드 사이에서 객체 참조를 전달하고, 서로 다른 전역 컨텍스트의 객체를 혼합하는 게 가능하다. 이는 놀라운 동작을 만들 수도 있다. 그림 9의 Javascript 1.1 코드 예시를 보자. 각각의 프레임은 자체적인 `Object` 생성자와 그 생성자로 만들어진 모든 객체들에게 상속되는 속성을 제공하는 `Object.prototype`을 가지고 있다. 그래서 한 프레임의 `Object.prototype`에 속성을 추가해도 다른 프레임의 `Object` 생성자로 만들어진 객체에는 그 속성이 보이지 않는다.

[^20]: 원래의 HTML `<frame>` 태그는 지금 구식으로 취급되며 `<iframe>`에 의해 대체되고 있다. 여기에 설명된 의미는 두 태그 모두에게 공통으로 적용되는 이야기이다.

```js
// The variable alien references an object created within a different frame
// by evaluating : new Object ()
var alien = createNewObjectInADifferentFrame();
var native = new Object(); // create an object in the current frame
Object.prototype.sharedProperty = " each frame has distinct built - ins ";
alert(native.sharedProperty); // displays : each frame has distinct built - ins
alert(alien.sharedProperty); // displays : undefined
```

그림 9. 서로 다른 HTML 프레임은 각각의 내장 객체를 가지고 있지만 객체를 공유할 수 있다는 것을 보여주는 Javascript 1.1 코드 예시

---

대화형 Javascript 웹 페이지는 브라우저가 제공하는 이벤트 루프와 함께 사용되는 이벤트 기반의 응용 프로그램이다. HyperCard[Apple Computer 1988]는 브랜든 아이크가 넷스케이프 2 DOM[Netscape 1996c]의 설계에서 이벤트 개념을 사용하도록 영감을 주었다. 원래 이벤트는 주로 사용자 상호작용에 의해 트리거되었었다. 하지만 현대 브라우저에서는 많은 종류의 이벤트가 있으며, 그 중 일부만 사용자가 발생시킨다.

웹 페이지에 정의된 모든 스크립트가 실행되고 나면 페이지의 Javascript 환경은 이벤트가 발생하기를 기다리는 활성 상태로 남아 있다. 이벤트 핸들러는 여러 DOM 객체를 포함하여 브라우저가 제공하는 객체와 연결될 수 있다. 이벤트 핸들러는 이벤트 발생에 대한 응답으로 호출되는 Javascript 함수일 뿐이다. 브라우저 객체의 특정 속성에 함수를 할당하면 그 함수는 해당 속성과 관련된 이벤트의 핸들러가 된다. 예를 들어 클릭 가능한 요소로 설정된 객체는 `onclick` 속성을 가지고 있다. Javascript 이벤트 핸들러는 다음과 같이 HTML 요소 내에서 Javascript 코드를 사용하여 직접 정의될 수도 있다.

```html
<button onclick="doSomethingWhenClicked()">Click me</button>
```

HTML 요소가 처리될 때 브라우저는 Javascript 함수를 생성하고 버튼 객체의 onclick 속성 값으로 할당한다. onclick에 할당된 코드는 함수 본문으로 사용된다. Javascript 이벤트 핸들러가 설정되어 있는 이벤트가 발생하면 그 이벤트는 대기 중인 이벤트 풀에 들어간다. 실행중인 Javascript 코드가 없을 때 브라우저는 이벤트 풀에서 대기 중인 이벤트를 가져와서 연관된 이벤트 핸들러 함수를 호출한다. 스크립트와 마찬가지로 이벤트 핸들러 함수도 완료될 때까지 실행된다.

## 3.7. Javascript의 이상한 점과 버그들(Oddities and Bugs)

Javascript에는 몇몇 이상하거나 예상치 못한 기능들이 있다. 일부는 의도적이었고 다른 일부는 Javascript의 전신인 모카를 만들기 위한 단 10일 간의 스프린트 동안 이루어진 급한 설계 결정의 산물이었다. Javascript 1.0에는 또한 버그들과 불완전하게 구현된 기능들도 있었다.

### 3.7.1. 재정의(Redundant Declarations)

JavaScript는 스코프 내에서 같은 이름을 가진 선언을 허용한다. 함수 내부에서 발생한 이름의 모든 선언은 함수 본문 전체에서 보이는 단일 바인딩에 해당한다. 예를 들어 다음은 유효한 함수 정의이다.

```js
function f(x, x) { // x names the second parameter , ignores 1st x
    var x; // same binding as second parameter
    for (var x in obj) { // same binding as second parameter
        var x = 1,
            x = 2; // same bindings as second parameter
    }
    var x = 3; // same binding as second parameter
}
```

함수 `f` 내의 모든 `var` 선언은 동일한 변수 바인딩을 참조한다. 이는 함수의 2번째 매개변수에 대한 바인딩과도 같다. 같은 이름이 함수의 형식 매개변수 목록에 여러 번 나타날 수도 있다. 함수 본문을 실행하기 전에 `var` 선언에 의해 정의된 변수들은 모두 `undefined`로 초기화된다. 그러나 매개변수 이름과 동일한 이름을 가진 `var` 변수의 경우에는 같은 이름을 가진 매개변수와 같은 초기값을 가진다. 중복 선언을 포함하여 `var` 선언의 초기화는 초기화된 변수에 대한 할당과 동일한 의미를 가진다. 이들은 함수 본문 내에서 정상적인 실행 순서에 도달했을 때 실행된다.

스크립트 내에서 동일한 이름의 여러 함수 선언 즉 `function` 키워드가 쓰인 곳이 있을 수도 있다. 그럴 경우 동일한 이름의 함수 선언들 중 마지막 함수 선언이 해당 이름으로 사용된다. 그리고 이 함수 선언은 스크립트의 최상단으로 끌어올려져서 그 이름과 같은 전역 변수를 초기화하는 데에 사용된다. 같은 이름의 다른 모든 `function` 선언은 무시된다. 동일한 이름에 대해 `function` 선언과 `var` 변수 선언이 동시에 있을 경우 그들은 모두 동일한 변수를 참조한다. 그리고 코드를 한 줄씩 실행하는 도중에 `var` 선언을 통한 초기화가 발견되면 함수 값은 덮어씌워진다.

### 3.7.2. 자동 형변환과 == 연산자(Automatic Coercions and the == Operator)

자동 형변환은 Javascript가 간단한 스크립트 언어로 도입될 때 진입 장벽을 낮추기 위해 만들어졌다. 하지만 Javascript가 일반 목적의 언어로 발전해 감에 따라서 이런 형변환은 혼란과 버그의 주요한 원인임이 증명되었다. 이는 특히 `==` 연산자에서 두드러진다. 모카의 초기 10일간의 스프린트 이후 알파 유저들의 요청에 의해 몇 가지 문제가 되는 형변환이 추가되었다. 이는 Javascript와 HTTP/HTML의 통합을 쉽게 만들기 위한 요구 사항이었다. 예를 들어서 넷스케이프의 내부 사용자들은 문자열 값 `"404"`를 포함하는 HTTP 상태 코드가 `==` 연산자를 통해 숫자 404와 동일하게 비교되기를 원했다. 또한 그들은 HTML 폼의 빈 필드에 대한 기본값을 제공하기 위해 빈 문자열이 숫자 맥락에 있을 때는 0으로 자동 형변환되기를 요구했다. 이런 형변환은 다음과 같은 놀라운 결과를 가져왔다. `1 == '1'`과 `1 == '1.0'`은 참이지만 `'1' != '1.0'`이다.

Javascript 1.0은 `if` 문의 조건에서 `=` 연산자를 `==`와 똑같이 취급한다. 예를 들어 다음 두 줄의 코드는 같은 의미이다.

```js
if (a = 0) alert("true"); // these two statements are equivalent
if (a == 0) alert("true");
```

### 3.7.3. 32비트 산수(32-bit Arithmetic)

Javascript의 비트 논리 연산자는 IEEE double 부동 소수점 인코딩 내에 있는 32비트 값에 작용한다. 비트 연산자는 비트 연산을 수행하기 위해 먼저 피연산자를 정수로 잘라내고 32비트 2의 보수 값으로 모듈러 변환을 수행한다. 그래서 표현식 `x|0`(`|`는 비트 or 연산자)에서 숫자값 `x`는 32비트 값으로 강제될 수 있다. 이런 방식을 사용하여 32비트 부호 있는 덧셈을 이렇게 수행할 수 있다.

```js
function int32bitAdd(x, y) {
    return ((x | 0) + (y | 0)) | 0 // addition with result truncated to 32-bits
}
```

부호 없는 32비트 연산도 할 수 있다. `|0` 대신 부호 없는 오른쪽 쉬프트 연산자를 사용해 `>>>0`과 같이 하면 된다.

### 3.7.4. this 키워드(The this keyword)

모든 함수는 `this` 매개변수를 암시적으로 가지고 있다. 함수가 메소드 형식으로 호출될 때 `this` 매개변수는 메소드에 접근하기 위해 사용된 객체로 설정된다. 이는 대부분의 객체 지향 언어에서 `this`(또는 `self`)에 부여된 의미와 동일하다. 그러나 Javascript는 독립된 함수와 객체 메서드에 대해 같은 형식으로 정의하는데 이 둘의 this 매개변수는 서로 다른 의미를 가지기 때문에 이는 많은 프로그래머들에게 있어 혼란과 버그의 원인이 되었다.

함수가 객체를 통하지 않고 직접 호출되면 `this`는 암시적으로 전역 객체로 설정된다. 전역 객체의 속성에는 프로그램의 모든 전역 변수가 포함된다. 그래서 독립적으로 호출된 함수에서의 `this`의 속성 참조는 전역 변수에 대한 참조와 같다. `this`의 처리가 함수가 어떤 방식으로 호출되는지에 따라 달라지기 때문에 같은 `this` 참조도 다른 방식의 호출에서 다른 의미를 가질 수 있다. 예를 들어 이런 것이다.

```js
function setX(value) {
    this.x = value
}
var obj = new Object;
obj.setX = setX; // install setX as a method of obj

obj.setX(42); // calls setX as a method
alert(obj.x); // displays : 42

setX(84); // directly call setX
alert(x); // accesses global variable x; displays 84
alert(obj.x); // displays : 42
```

`this`에 대한 혼란을 일으키는 다른 요인도 있다. 몇몇 HTML 요소들은 Javascript 코드를 메서드로 호출되도록 암시적으로 변환한다. 예를 들어 다음과 같은 HTML 코드가 있다고 하자.

```html
<button name="B" onclick='alert(this.name + " clicked")'>Click me</button>
```

이벤트 핸들러가 실행되면 버튼의 `onclick` 메서드가 호출된다. 해당 메서드의 `this`는 버튼 객체를 가리키며 `this.name`은 버튼 객체의 `name` 속성값을 검색한다.

### 3.7.5. 인수 객체(Arguments objects)

함수의 `arguments`객체는 함수의 형식 매개변수와 연결되어 있다. `argument` 객체의 숫자 인덱스 속성과 함수의 형식 매개변수 사이에는 동적 매핑이 있다. `arguments` 객체 속성의 변경은 상응하는 형식 매개변수의 값을 변경하며, 형식 매개변수를 변경하면 그 위치에 대응되는 `arguments` 객체 속성의 변경을 관찰할 수 있다.

```js
f(1, 2);

function f(argA, argB) {
    alert(argA); // displays : 1
    alert(f.arguments[0]); // displays : 1
    f.arguments[0] = "one";
    alert(argA); // displays : one
    argB = "two";
    alert(f.arguments[1]); // displays : two
    alert(f.arguments.argB); // displays : two
}
```

위 코드 예제의 마지막 줄에서 볼 수 있듯이 `arguments` 객체의 속성 키에 형식 매개변수 이름을 넣음으로써 해당 형식 매개변수에 접근할 수 있다. 예를 들어서 `f.arguments.argB`는 해당 함수의 `argB` 매개변수에 접근한다.

개념적으로 함수가 호출되면 함수의 새로운 동작을 위해 새로운 `arguments` 객체가 생성되고 함수 객체의 `arguments` 속성 값이 그 새로운 `arguments` 객체로 설정된다. 하지만 자바스크립트 1.0/1.1에서는 함수 객체와 `arguments` 객체가 동일한 객체이다.

```js
function f(a, b) {
    if (f == f.arguments) alert("f and f.arguments are the same object")
}
if (f.arguments == null) alert("but only while a call to f is active")
```

이상적으로는 함수의 `arguments` 객체는 해당 함수의 본문 내에서만 접근 가능해야 한다. 이는 함수가 반환될 때 자동으로 `arguments` 속성을 `null`로 설정함으로써 부분적으로 강제된다. 하지만 `f1`과 `f2`라는 두 함수가 있다고 가정해 보자. `f1`이 `f2`를 호출하면 `f2`의 함수 본문에서는 `f1.arguments`을 통해 `f1`의 인자들에 접근할 수 있다.

`arguments` 객체에는 `caller`라는 속성도 있다. `caller`속성의 값은 현재 함수를 호출한 함수 객체이거나 만약 가장 바깥쪽 즉 전역에서 호출되었을 경우 `null`이다. `caller`와 `arguments`를 사용함으로써 어떤 함수든 현재 콜스택에 있는 함수들과 그들의 인자들을 검사할 수 있다. 그리고 심지어 콜스택에 있는 함수들의 형식 매개변수 값을 수정할 수도 있다. 같은 의미의 `caller` 속성은 `arguments` 객체를 거치지 않고 함수 객체를 통해 직접 접근할 수도 있다.

### 3.7.6. 숫자 속성 키의 특별 취급(Special Treatment of Numeric Property Keys)

Javascript 1.0에서 대괄호 표기법은 숫자 키와 함께 쓰였을 경우 특이한 의미를 가졌다. 어떤 경우 대괄호로 둘러싸인 정수 키는 객체 속성이 생성된 순서대로 속성에 접근했다. 정수를 통해서 속성이 생성된 순서에 따라 속성에 접근하게 되는 것은 해당 키를 가진 속성이 객체에 존재하지 않고 정수의 값 n이 객체 속성의 총 개수보다 작은 경우에만 발생한다. 그럴 경우 `객체[n]`과 같이 숫자 키로 속성에 접근하면 그 객체에 생성된 n번째 속성(0부터 시작)에 접근하게 된다. 예를 들어 다음과 같은 코드가 있다고 하자.

```js
var a = new Object ; // or new Array
a[0] = " zero ";
a[1] = " one";
a.p1 = "two";

alert (a [2]) ; // displays : two
a[2] = "2";
alert (a.p1) ; // displays : 2
```

Javascript 1.1에서는 이런 대괄호 표기법의 특이한 동작을 제거했다.

### 3.7.7. 원시값의 속성(Properties of Primitive Values)

Javascript 1.0에서 숫자형과 불린값은 속성을 갖지 않았다. 그리고 그 값들의 속성에 접근하거나 속성을 지정하려고 하면 에러 메시지가 발생했다. 문자열 값은 속성을 가진 객체처럼 동작하지만, 읽기 전용인 `length` 속성을 제외하고는 모두 동일한 속성을 공유합니다. 다음과 같은 코드를 보면 그걸 알 수 있다.

```js
"xyz".prop = 42; // Set the value of property prop to 42 for all strings
alert("xyz".prop); // displays : 42
alert("abc".prop); // displays : 42
```

Javascript 1.1에서는 숫자, 불린, 문자열 값에 대한 속성 접근이나 할당은 내장된 `Number`, `Boolean`, `String` 생성자를 이용해 암시적으로 "래퍼 객체(wrapper object)"를 만들도록 한다. 이 속성 접근은 래퍼 객체에 수행된다. 그리고 일반적으로 내장 프로토타입에서 상속받은 속성에 접근한다. `valueOf`와 `toString` 메서드의 자동 호출로 이루어지는 형변환은 대부분의 상황에서 래퍼 객체를 원시값처럼 사용할 수 있게 한다. 할당을 통해 래퍼 객체에 새로운 속성을 만들 수는 있지만, 암시적으로 생성된 래퍼는 일반적으로 할당 직후에는 접근할 수 없게 된다. 예를 들어 다음과 같은 코드를 보자.

```js
" xyz".prop = 42; // Set the value of a String wrapper property to 42
alert("xyz".prop); // Implicitly creates another wrapper , displays: undefined
var abc = new String("abc"); // Explicitly create a wrapper object
alert(abc + "xyz"); // Implicitly converts wrapper to string , displays: abcxyz
abc.prop = 42; // create a property on a wrapper objects
alert(abc.prop); // display: 42
```

### 3.7.8. Javascript 내부의 HTML 주석(HTML Comments Inside JavaScript)

넷스케이프 2에서는 Javascript의 잠재적인 상호 운용성 문제가 있었다. 이는 넷스케이프 1과 모자이크 브라우저가 HTML의 `<script>` 요소를 만났을 때 어떻게 했는지와 관련이 있었다. 구식이지만 널리 사용되던 이런 브라우저들은 Javascript 코드를 담은 `<script>` 요소를 만나면 해당 요소의 본문을 웹 페이지에 일반 텍스트로 표시했다. 이런 구식 브라우저들에서 발생하던 문제는 HTML 주석[^21]으로 스크립트 본문을 감싸는 것으로 방지할 수 있었다. 예를 들어 이런 식으로 말이다.

```html
<script>
  <!-- This is an HTML comment surrounding a script body
  alert("this is a message from JavaScript"); // not visible to old browsers
  // the following line ends the HTML comment
  -->
</script>
```

이런 코딩 패턴을 사용하면 넷스케이프 1과 모자이크의 HTML 파서는 전체 스크립트 본문을 HTML 주석으로 인식하고 페이지에 표시하지 않았다. 하지만 모카가 처음 구현되었을 때 이런 패턴을 사용하면 브라우저가 스크립트 본문을 파싱하고 실행하지 못했다. HTML 주석 구분자가 Javascript 코드에서 문법적으로 유효하지 않았기 때문이다. 이 문제를 피하기 위해 브랜던 아이크는 Javascript 1.0에서 `<!--`가 한 줄 주석의 시작으로 인식되도록 했다. 이는 `//`와 동일하다. 하지만 `-->`는 Javascript 주석의 구분자로 만들지 않았다. 이 패턴을 사용할 때 `-->`의 앞에 `//`를 두는 것으로 충분했기 때문이다. 그래서 하위 호환성이 있는 스크립트는 다음과 같이 작성할 수 있었다.

```html
<script>
  <!-- This is an HTML comment in old browsers and a JS single line comment
  alert("this is a message from JavaScript"); // not visible to old browsers
  // the following line ends the HTML comment and is a JS single line comment
  // -->
</script>
```

`<!--`주석은 공식 Javascript 문법에 문서화되지는 않았다. 하지만 많은 웹 개발자가 사용하였고 다른 브라우저들의 Javascript 구현에서 지원되었다. 그 결과로 `<!--` 는 웹 현실(Web Reality$^{g}$)의 사실상의 표준이 되었다. 그래서 20년이 걸렸지만 2015년에 `<!--`주석은 ECMAScript 표준에 추가되었다. 결국 실질적으로 쓰이는 게 언제나 승리한다.

# 4. Microsoft JScript[^22]

넷스케이프와 선이 Javascript를 발표한 주에 마이크로소프는 비주얼 베이직을 "비주얼 베이직 스크립트를 사용해서 월드 와이드 웹 기반 애플리케이션을 만드는 표준"으로 만들겠다고 발표했다[Wingfield 1995]. 마이크로소프트는 1996년 5월 29일 인터넷 익스플로러 3.0 베타 릴리즈에서 Javascript에 대한 지원을 공식적으로 발표했다[Microsoft 1996]. 그 발표 내용은 다음과 같았다.

---

**ActiveX Script** 비주얼 베이직 스크립트와 Javascript에 대한 네이티브 지원을 통해 마이크로소프트 인터넷 익스플로러 3.0은 가장 포괄적이고 언어와 독립적인 스크립트 기능을 제공합니다. 마이크로소프트 인터넷 익스플로러는 REXX, CGI, PERL과 같은 추가적인 스크립팅 언어를 지원하도록 확장될 수 있습니다. 웹 페이지 디자이너들은 어떠한 스크립팅 언어도 그들의 HTML 코드에 삽입하여 액티브X 컨트롤, Java Applet, 기타 소프트웨어 구성 요소들을 연결하고 사용자와 상호 작용하는 페이지를 만들 수 있습니다.

---

[^21]: 스크립트 본문에는 HTML 주석에서 허용되지 않는 `>` 또는 `--` 연산자가 포함되어 있지 않아야 한다.
[^22]: 이 섹션의 대부분 자료는 2018년 3월 22일에 Allen Wirfs-Brock이 Robert Welland, Shon Katzenberger, Peter Kukol과 진행한 인터뷰 기록을 바탕으로 작성되었다[Welland et al. 2018].

---

훗날 JScript라고 불리게 될 작업은 1995년 10월 로버트 웰랜드가 마이크로소프트의 인터넷 익스플로러(IE) 팀에 합류하면서 시작되었다. 웰랜드는 이전에 애플에서 뉴턴 휴대용 컴퓨터와 뉴턴스크립트 언어 [Smith 1995]에 대한 작업을 하였다. 뉴턴스크립트는 Self 언어에 의해 영향을 받은 프로토타입 기반의 객체 지향 언어였다. 웰랜드는 뉴턴스크립트의 주요 설계자인 월터 스미스와 프로젝트에 컨설턴트로 참여했던 데이비드 웅거와 긴밀하게 협업했었다. 그래서 웰랜드는 프로토타입 기반 언어에 대한 웅거의 아이디어와 Self에 매우 익숙했다. 애플을 떠난 후 웰랜드는 어떻게 브라우저에 스크립팅을 추가할지에 대해 고민했다. 이는 그가 인터넷 익스플로러에 스크립팅을 넣는 일을 하게 되는 계기가 되었다.  

마이크로소프트에 도착한 웰랜드는 IE에 비주얼 베이직을 넣어야 한다는 지시를 받았다. 하지만 그가 마이크로소프트의 개발자 도구 부서(DevDiv$^{g}$)의 비주얼 베이직 팀에 문의했을 때 그 작업이 2년이 걸릴 것이라는 답변을 받았다. 그와 샘 맥켈비는 IE2에서 애플리케이션을 위한 비주얼 베이직(Visual Basic for Applications)[^23]을 실행시키는 작업을 빠르게 진행했지만, 브라우저 객체 모델과 통합하기는 너무 복잡했다. 웰랜드는 넷스케이프 2 공개 베타에서 LiveScript/Javascript를 관찰하고 Javascript를 위한 간단한 바이트코드 인터프리터를 실험하기 시작했고 맥켈비가 그것을 개선했다. 웰랜드는 DevDiv의 피터 쿠콜이 바이트코드를 생성할 수 있는 Javascript 파서[^24]를 작성한 것을 발견했다. 웰랜드와 맥켈비는 그들의 인터프리터와 쿠콜의 파서, 그리고 패트릭 두수드가 작성한 가비지 컬렉터를 연결하여 JScript의 기초적인 구조를 만들었다.

마이크로소프트의 DevDiv는 마이크로소프트의 모든 프로그래밍 언어와 개발자 도구의 개발을 담당하고 있었다. 그래서 윈도우 부서의 IE 팀에서 일하는 로버트 웰랜드와 샘 멕켈비가 새로운 언어 구현의 개발에 관여하는 것은 정치적으로 민감한 문제였다. 또한 IE가 Javascript를 지원해야 하는지에 대한 내부적인 논란도 있었다. DevDiv는 스크립팅을 위한 비주얼 베이직과 애플리케이션을 위한 자바에 집중하고자 했다. 그러나 IE 팀의 목표는 IE3이 넷스케이프 3와 호환되도록 하는 게 목표였다. 이를 위해서는 Javascript 지원이 필요했다. 마이크로소프트는 Javascript를 지원해야 한다는 사실이 만족스럽지 않았지만 이를 무시하기에는 너무 늦었다. IE와 마이크로소프트가 모두 함께 Javascript와 비주얼 베이직 모두를 스크립팅을 위해 지원하고, 스크립팅 언어에 대한 담당은 DevDiv가 맡는 것으로 타협했다. IE/윈도우 팀은 브라우저와 기타 제품에 스크립팅을 통합하는 것을 맡았다.

1996년 1월, 샘 멕켈비는 DevDiv로 팀 이동을 했고 로버트 웰랜드는 IE 팀에 남아 있었다. 또한 1월에는 마이크로소프트 워드 팀에서 DevDiv로 전근한 쇼운 카첸버거가 스크립팅에 관한 작업을 시작하였다. 카첸버거는 인터프리터를 담당하게 되었다. 그리고 비주얼 베이직 팀의 도움을 받아서 같은 인터프리터에서 실행되는 비주얼 베이직의 스크립트 하위 집합을 구성하였다. 이건 비주얼 베이직 스크립트 또는 VBS로 알려지게 되었다.

웰랜드와 멕켈비는 JScript와 VBS 모두를 지원하는 스크립팅 시스템을 임베딩 가능한 컴포넌트로 구성했다. 이는 Active Scripting이라는 이름으로 알려지게 된다. 이 컴포넌트는 1996년 IE3와 마이크로소프트의 웹 서버 제품인 IIS의 일부로 출시되었다. IIS는 Active Server Pages에 서버사이드 스크립팅 기술을 제공했다. Active Scripting은 이후 마이크로소프트 윈도우즈의 표준 구성 요소가 되었고 2019년까지 여전히 레거시 애플리케이션을 지원하기 위해 사용 가능하였다.

IE 팀은 넷스케이프와의 경쟁에 매우 집중하였다. 그들은 Active Scripting의 기능이었던 스크립트 디버거가 Javascript 웹 개발자들을 끌어들일 것을 기대했다. 넷스케이프에는 Javascript 디버거가 없었기 때문이다. 하지만 그들은 또한 넷스케이프와의 웹사이트 상호 호환성이 IE의 도입에 필수적임을 알고 있었다. 쇼운 카첸버거 등의 사람들은 Javascript를 사용하는 수천 개의 웹사이트에서 IE3의 개발 버전을 실행하고 넷스케이프 2와 넷스케이프 3의 결과와 비교하였다. 차이점을 발견할 때마다 카첸버거는 무엇이 어떻게 다르게 동작하는지를 이해하기 위해 넷스케이프 Javascript 동작을 리버스 엔지니어링했다. 그들은 넷스케이프 Javascript의 몇몇 동작들에 크게 놀랐다. 특히 넷스케이프의 구현에서 HTML 프레임들이 공통 객체 주소 공간을 공유하고 객체들을 자유롭게 교환할 수 있다는 것을 알았을 때 특히 놀랐다. IE는 각각의 프레임을 고립된 환경으로 구현했으며 객체들이 그들 간에 전달될 수 있도록 상당히 많은 재설계가 필요했다.

JScript 개발 과정을 통틀어, 적절한 언어 사양의 부재는 늘 문제였다. 웰랜드가 회상한 바에 따르면, IE3의 개발을 종합적으로 이끌었던 토마스 리어든이 언제나 Javascript 언어 명세가 없는 것을 불평하며 넷스케이프를 비난했다고 한다.

[^23]: Visual Basic for Applications는 Visual Basic 6의 변종으로 마이크로소프트 오피스 어플리케이션에 포함되었다.
[^24]: 2018년 인터뷰 당시 쿠콜은 자기가 최근에 마이크로소프트의 Javascript 팀에 방문했는데 그가 작성했던 파서 원본이 확장들과 함께 마이크로소프트의 그 시점 Javascript 구현과 여전히 사용되고 있는 것을 보았다고 이야기했다.

# 5. 모카에서 스파이더몽키까지(From Mocha to SpiderMonkey)

1995년 전체와 1996년 대부분 기간 동안, 브랜든 아이크는 넷스케이프에서 Javascript 엔진$^{g}$[^25]을 담당하는 유일한 풀타임 개발자였다. 1996년 8월 넷스케이프 3.0의 프로덕션 릴리즈에 포함된 Javascript 1.1은 여전히 주로 1995년 5월의 열흘간 만들어진 프로토타입에서 나온 코드로 구성되어 있었다. 이 릴리즈 이후 아이크는 엔진^{g}의 기술 부채[^26]를 청산하고 Javascript를 "더 깔끔한 언어"로 만드는 작업을 시작할 때라고 느꼈다. 넷스케이프 경영진은 그가 언어 명세 작업을 하기를 원했다. 그들은 Javascript에 명세가 없다는 마이크로소프트의 비판에 민감했고 곧 시작될 표준화 작업 활동의 시작이 명세를 요구할 것으로 예상했다. 아이크는 이에 저항했다. 그는 모카를 재구현하는 것부터 시작하고자 했다. 명세를 작성하려면 모카 구현을 신중하게 검토해야 했다. 그는 검토하면서 모카를 다시 작성하는 것이 가장 효율적일 것이라고 생각했다. 이는 또한 원본의 설계 실수를 명세에 넣어버리기 전에 고칠 수 있게 해줄 것이었다.

이 논쟁에 좌절한 아이크는 사무실을 떠나 2주 동안 집에서 일하면서 Javascript 엔진의 핵심부를 재설계하고 재구현했다. 그 결과는 더 빠르고, 더 신뢰할 수 있으며, 더 유연한 실행 엔진이었다. 그는 원래 Javascript의 값들을 discriminated union$^{g}$으로 표현했는데 이를 폐기하고 대신 원시값이 직접적으로 포함된 tagged pointer를 사용했다. 그리고 원래 엔진에는 포함되지 않았던 중첩 함수, 함수 표현식, switch문 등의 기능을 구현했다. 레퍼런스 카운팅 형식의 메모리 관리자는 마크 앤 스윕 가비지 컬렉터로 대체되었다.

아이크가 사무실로 돌아왔을 때, 새로운 엔진은 모카를 대체했다. 넷스케이프의 원래 개발자 중 한 명인 크리스 하우크가 아이크와 함께 Javascript 팀의 두 번째 풀타임 멤버로 합류했다. 하우크는 새 엔진을 "“SpiderMonkey$^{g}$"로 명명했다. 이는 영화 비비스와 버트헤드(Beavis and Butt-Head Do America)에 나오는 외설적인 대사에서 따온 거였다[Judge et al. 1996]. 클레이턴 루이스가 팀에 매니저로 합류했고 노리스 보이드를 고용했다. 테크니컬 라이터 랜드 맥키니가 아이크의 명세 작성을 돕기 위해 배정되었다.

브렌던 아이크는 넷스케이프 4.0 릴리즈에 들어갈 Javascript 1.2를 계속 개선했다.그 첫번째 베타 릴리즈는 1996년 12월이었다. 정규 표현식은 1997년 4월 베타에 추가되었다. 다양한 플랫폼을 지원하는 넷스케이프 4의 프로덕션 릴리즈는 6월에 시작되어 1997년 하반기에 걸쳐 이루어졌다.

---

[^25]: Javascript 커뮤니티에서 "엔진"이라는 용어는 Javascript의 언어 구현을 가리킨다. Javascript 엔진은 일반적으로 파서, 가상 머신이나 비슷한 런타임 지원, 가비지 컬렉터, 표준 라이브러리 구현과 다른 구성 요소들로 구성된다.
[^26]: "기술 부채"는 브랜든 아이크가 회고하면서 사용한 용어다. 아이크가 미뤄졌던 유지보수를 해야 했던 필요성을 나타내기 위해 1996년에 썼던 용어가 "기술 부채"인 건 아니다.
[^27]: SpiderMonkey는 이후의 넷스케이프와 모질라 브라우저에 있는 Javascript 하위 체제를 나타내는 이름이 되었다. 2020년에도 모질라는 그 이름을 쓴다. 실제의 구현 기술은 몇 번 바뀌었는데도 말이다.

---

![그림 10](./pictures/figure10.png)

SpiderMonkey에 의해 구현된 Javascript 1.2 언어와 내장 라이브러리는 Javascript 1.0/1.1에 비해 상당한 개선을 이루었다. 그림 10은 Javascript 1.2의 주요한 새 기능들을 나열한 것이다[Netscape 1997c]. Javascript 1.2의 라이브러리 추가 사항 대부분은 다른 인기 있는 언어들의 기능에서 영향을 받은 것이다. 배열의 `concat`, `slice` 메소드는 Python의 시퀀스 연산에서 영감을 받았다. 배열의 `push`, `pop`, `shift`, `unshift`, `splice`는 비슷한 이름을 가진 Perl의 배열 함수를 직접적으로 따왔다. 문자열의 `concat`, `slice`, `search` 메소드는 Python에서 영향을 받았고, 문자열 `match`, `replace`, `substr`은 Perl에서 왔다. Java는 `charCodeAt`에 영향을 주었다. 정규 표현식과 문자열 매칭의 문법과 의미는 Perl에서 차용되었다.

문장 수준의 추가 사항들은 C 계열 언어에 익숙한 프로그래머들이 기대했지만 이전에는 빠져 있던 문장들을 제공했다. `do` 문은 C의 `do` 문의 문법과 유사한 의미를 직접 복제해왔다. Javascript 1.0에는 해당 기능이 빠져 있었다. 레이블 문과 `break`, `continue`에 레이블을 붙이는 것은 Java의 같은 기능을 모델로 삼았다. 해당 기능은 중첩된 반복문과 `switch`문에서 여러 중첩 레벨을 탈출하는 것을 가능하게 하고 비반복적인 코드 블럭에서 조기 탈출도 가능하게 한다. Javascript 1.2의 `switch`문은 C와 Java처럼 `case` 선택자 표현식의 컴파일 타임 평가를 포함하고 있었다[Eich et al. 1998, jsemit.c lines 757–776].

Javascript 1.0/1.1에서는 함수가 스크립트의 최상위 스코프에서만 전역 선언을 통해 정의될 수 있었다. Javascript 1.2는 다른 함수 내부에서 지역 선언을 사용해서 내부 함수를 정의할 수 있게 허용했다. 이런 내부 함수는 무제한으로 중첩될 수 있다. 내부 함수에는 렉시컬 스코프가 지정되며 내부 함수의 지역 선언은 외부 스코프에서 동일한 이름으로 선언된 것을 덮어쓴다. Javascript 1.0/1.1에서는 최상위 레벨의 `var`와 `function` 선언이 스크립트의 최상단으로 "끌어올려졌다(hoisted)". 그리고 함수의 지역적인 `var` 선언도 함수 본문의 시작 부분으로 끌어올려졌다. 그래서 변수와 함수가 선언되기 전에 참조하는 것이 가능했다. Javascript 1.2에서는 중첩된 `function` 선언도 해당 함수를 포함하는 외부 함수 본문의 시작 부분으로 끌어올려지게 되었다. 같은 이름을 가지는 `function` 선언이 2개 이상 있을 경우 이를 감싸는 함수 스코프의 소스코드 상에서 맨 마지막에 나오는 것이 이름에 바인딩된다.

Javascript 1.2는 함수 정의가 표현식 형태로 나타나는 것을 허용함으로써 람다 표현식을 제공했다. 이들은 "함수 표현식(function expressions)"이라고 불렸다. 그리고 함수 이름이 선택 사항인 것을 제외하고는 함수 선언과 문법적으로 동일하다. 만약 이름이 있으면 함수 표현식은 바인딩 목적으로 스코프 최상단으로 끌어올려진 `function` 함수 선언으로 취급된다. 함수 이름이 없는 함수 표현식은 익명 함수를 정의한다. 어느 경우에든, 함수 표현식의 런타임 평가는 새로운 클로저를 생성한다. `arguments` 객체에 `callee` 속성을 추가함으로써 이러한 클로저들이 자기 자신을 재귀적으로 참조할 수 있게 되었다.

배열 리터럴과 객체 리터럴[^28]은 Python 언어의 유사한 기능에서 영감을 받았다. 배열 리터럴은 배열 객체의 요소를 생성하고 초기화하기 위한 간결한 문법을 제공한다. Javascript 프로그래머는 배열 리터럴을 사용하면 이렇게 작성할 수 있다.

```js
var p2 = [1, 2, 4, 8, 16, 32, 64];
```

원래 Javascript 1.1에서는 이렇게 해야 했다.

```js
var p2 = new Array();
p2[0] = 1;
p2[1] = 2;
p2[2] = 4;
// etc.
```

비슷하게 객체 리터럴은 객체를 생성하고 속성을 만들기 위한 간결한 문법을 제공했다. 객체 리터럴은 이렇게 작성할 수 있다.

```js
var origin = {
    x: 0,
    y: 0
};
```

원래 Javascript 1.1에서는 이렇게 해야 했다.

```js
var origin = new Object;
origin.x = 0;
origin.y = 0;
```

객체 리터럴과 함수 표현식의 조합은 클래스 없이도 메서드를 가지는 객체를 생성하는 것을 쉽게 만들었다. 예시로 다음과 같은 코드를 들 수 있다.

```js
function Point(x, y) {
	return {
		x: x,
		y: y,
		distance: function(another) {
			return Math.sqrt(Math.pow(this.x - another.x, 2) +
				Math.pow(this.y - another.y, 2));
		}
	}
}

var origin = new Point(0, 0);
alert(origin.distance(new Point(5, 5)));
```

[^28]: Javascript 1.2 문서와 ES3 명세는 이를 "배열 이니셜라이저"와 "객체 이니셜라이저"라고 불렀다. 하지만 "리터럴"이라는 용어가 Javascript 프로그래머들에게 널리 퍼져 있고 여러 아티클과 책에서도 일반적으로 "리터럴"이라는 용어를 사용한다.

---

객체 리터럴과 함수 표현식을 결합하면 프로토타입 객체를 더 편리하게 정의할 수도 있다. 또한 Javascript 프로그램이 객체의 프로토타입 객체 참조를 동적으로 접근하고 수정할 수 있도록 해주는 `__proto__` 의사 속성(pseudo-property)를 추가했다. 이 속성을 사용하면 각 객체가 상속된 속성에 접근하기 위해서 사용하는 내부 참조를 동적으로 접근하고 수정할 수 있다[^29]. `__proto__`를 사용하면 프로그램은 임의의 깊이의 상속 계층을 동적으로 구성하고 객체가 상속된 속성을 가져오는 출처도 동적으로 변경할 수 있다.

Javascript 1.2의 일부 변경 사항은 결국 좋지 못한 결정이었던 게 드러났다. `import`와 `export` 문은 넷스케이프 4에서 제공된, Java와 호환 가능한 스크립트 서명 메커니즘(script signing mechanism)[Netscape 1997a]과 같이 사용하기 위해 만들어졌다. 서명된 스크립트에서 정의된 전역 변수들은 `export` 문을 사용해 명시적으로 내보낸 함수들을 제외하고 다른 스크립트에서는 접근할 수 없었다. (번역자: 지금의 private와 비슷한 기능으로 보인다) 이 기능은 넷스케이프 계열이 아닌 브라우저에서는 전혀 도입되지 않았다.

Javascript 1.0/1.1의 `==`연산자의 자동 형변환 규칙은 사용자들의 요구사항이었음에도 불구하고, 일부 사용자들은 그 동작이 놀랍고 혼란스럽다는 것을 깨닫고 있었다. 브랜든 아이크는 Javascript 1.2에서 `==`연산자의 자동 형변환 규칙 대부분을 제거함으로써 `==` 연산자를 고치기로 결정했다 [Netscape 1997d; Rein 1997]. 두 피연산자가 동일한 원시 타입(숫자, 문자열, 불리언, 객체)이 아니라면 `==`는 `false`를 반환하도록 했다.

Javascript 1.2에서는 여러 변경사항들이 있었는데, 이렇게 Javascript 1.0, 1.1로부터의 변화들은 `<script>` 태그의 `version` 속성을 통해 다루어질 수 있을 것으로 희망되었다. 하지만 Javascript 1.2 프로덕션 릴리즈 시점까지 이 형태의 버전 관리는 웹 개발자들에게 이미 관리하기 어려운 것이 되어 버렸다[Rein 1997]. 자체적인 Javascript 구현을 가진 비-넷스케이프 계열 브라우저들에서도 작동해야 하는 웹 페이지들에게는 특히 더 그러했다.

# 6. 막간: 비평(Interlude: Critics)

Javascript는 출시 극초기부터 매우 큰 비판의 대상이 되어왔다. 일부 비판은 동적 타입의 사용과 같은 설계상의 근본적인 결정이나 강제 형변환 규칙과 같은 설계 세부 사항들을 대상으로 했다. 다른 비판자들은 Javascript가 HTML과 통합되는 방식에 근본적으로 동의하지 않기도 했고, 브라우저 보안 취약점의 노출에 대해서 우려하기도 했다[Fair 1998]. 로버트 카이유[Wikinews 2007]은 Javascript를 "컴퓨팅 역사상 가장 끔찍하게 나쁜 설계"라고 하면서 "나는 C보다 나쁜 언어를 딱 하나 알고 있는데 그것은 Javascript다"(“I know only one programming language worse than C and that is Javascript[sic].”) 라고 말했다. 브랫 보스[Boss 2005]는 W3C 워크숍에서 Javascript를 "지금까지 만들어진 최악의 언어"라고 했다.

많은 초보 프로그래머들이 브라우저에서의 Javascript를 하면서 부동 소수점 연산상의 어려움과 같은 일반적인 프로그래밍에서의 문제들을 처음 접하게 된다. 그들은 일반적으로 이런 문제들이 Javascript에서만 나타나는 거라고 생각한다. 그리고 많은 숙련된 프로그래머들은 Javascript를 친숙한 프로그래밍 언어들과(또는 이름을 헷갈려서 Java와) 비교하고 부족하다고 여긴다. 자바스크립트의 기이한 점들(quirks)을 카탈로그화하는 기사들[Cardy 2011]과 `wtfjs.com`[Leroux 2010]과 같은 웹사이트는 웹의 주요한 요소가 되었다.
