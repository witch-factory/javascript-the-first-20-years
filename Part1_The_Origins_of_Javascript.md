# Part 1: Javascript의 기원

## 2. Javascript 이전 시대(Prehistory)

월드 와이드 웹의 개념과 기반 기술들은 1989-1991년에 CERN의 팀 버너스 리[2003]에 의해 개발되었다. 버너스 리의 웹 기술은 몇 년 동안 고에너지 관련 물리학 커뮤니티에서 유포되었다. 하지만 그 커뮤니티 외부에서는 많은 주목을 받지 못했다. 이 상황은 1992-1993년에 당시 학부생이었던 Marc Andreessen과 일리노이 대학교 어바나-샴페인 국립 슈퍼컴퓨팅 응용 프로그램 센터(NCSA)에서 일하던 에릭 비나가 Mosaic$^{g}$를 개발하면서 변화하기 시작했다.

NCSA 모자이크는 GUI(graphic user interface)를 갖춘 설치하기 쉽고 사용하기 쉬운 웹 클라이언트였다. 이것은 사실상 '웹 브라우저'라는 소프트웨어 분류를 정의했고 물리학 커뮤니티 외부에서 월드 와이드 웹의 개념을 대중화했다. 모자이크는 널리 배포되었고 이런 브라우저 열풍에 편승하기 위해 NCSA 모자이크의 라이센스를 얻거나 모자이크에서 영감을 얻은 브라우저를 처음부터 만드는 데에 상업적 관심이 쏠렸다. 실리콘 그래픽스 주식회사(Silicon Graphics Inc.)의 창립자 Jim Clark는 벤처캐피탈 투자를 얻은 후 Marc Andreessen과 Eric Bina를 고용했다. 그리고 1994년 4월 그들은 나중에 Netscape Communications Corporation으로 불릴 회사를 공동 창립한다. 넷스케이프는 NCSA 모자이크를 대체하고 세계에서 가장 인기있는 브라우저가 되는 것을 목표로 삼았다. 넷스케이프는 개선된 차세대 모자이크-like 브라우저를 처음부터 개발했고 1994년 10월 널리 배포하기 시작했다. 1995년 초까지 Netscape Navigator$^{g}$는 초기 목표를 달성하고 모자이크를 빠르게 대체하고 있었다.

팀 버너스 리의 웹 기술은 선언적인($declarative^{g}$) HTML 마크업 언어를 사용하여 웹 페이지로 문서를 표시하는 데에 중점을 두었다. 반면 스크립트 언어($scripting language^{g}$)[Ousterhout 1997]를 사용하여 최종 사용자가 애플리케이션 동작을 조직할 수 있도록 하는 데에도 상당한 산업적인 관심이 있었다. 마이크로소프트 오피스의 비주얼 베이직, 애플스크립트[Cook 2007]과 같은 언어들은 주요 애플리케이션의 핵심을 구성하는 복잡한 자료구조와 알고리즘 컴포넌트들을 구현하기 위해 만들어진 게 아니었다. 대신 이런 언어들은 사용자들이 이런 애플리케이션 구성 요소들을 새로운 방식으로 결합할 수 있도록 했다. 넷스케이프가 월드 와이드 웹을 더 많은 사람들에게 보급함에 따라, 스크립팅 언어가 어떻게 웹 페이지에 통합되어야 하는지는 중요한 질문이 되었다.

## 2.1. 브랜든 아이크가 넷스케이프에 합류

브랜든 아이크[^4]는 1985년 일리노이 어바나-샴페인 대학교에서 석사 학위를 마치고 즉시 실리콘 그래픽스 주식회사에서 일을 시작했다. 그는 주로 유닉스 커널과 네트워크 계층 작업을 했다. 1992년에 그는 SGI를 떠나 비디오 미디어 프로세서를 개발하는 자금이 풍부한 스타트업 마이크로유니티에 합류했다. 두 회사에서 그는 커널과 네트워크 프로그래밍 작업을 지원하는 작은 특수목적 언어를 구현했다. 마이크로유니티에서는 GCC 컴파일러$^{g}$에 대한 작업도 조금 했다.

1995년 초 브랜든 아이크는 "와서 브라우저에 Scheme을 구현해라"[^5]라는 말을 미끼로 넷스케이프에 고용된다. 그러나 1995년 4월 3일 아이크가 넷스케이프에 합류했을 때 그는 복잡한 제품 마케팅과 프로그래밍 언어에 관련된 상황을 마주한다. 넷스케이프는 1994년 말 마이크로소프트의 저가 인수 제안을 거절한다. 그 후 넷스케이프 경영진은 마이크로소프트의 "Embrace, Extend, Extinguish"전략[Wikipedia 2019]에 직접적으로 공격받을 것으로 예상했다. 빌 게이츠의 직접적인 경영하에 있던 마이크로소프트는 웹이 크로스-OS 플랫폼으로 부상함에 따라서 그들이 곧 출시할 사적인 환경의 정보 유틸리티인 프로젝트 블랙버드[Anderson 2007]가 무의미해질 것을 빠르게 깨달았다. 빌 게이츠의 "인터넷의 해일"[Gates 1995]메모는 마이크로소프트를 프로젝트 블랙버드에서 인터넷 익스플로러$^{g}$와 서버 제품군 쪽으로 완전히 전환시켰다. 그 시점에 넷스케이프는 해당 시장을 점유하기 위해 서둘렀다.

웹 페이지의 스크립트 언어 후보로는 Scheme과 같은 연구용 언어와 Perl, Python, Tcl과 같은 실용적인 유닉스 기반 언어, 그리고 마이크로소프트의 비주얼 베이직과 같은 독점권이 있는 언어들이 있었다. 브랜든 아이크는 브라우저에 Scheme을 구현할 것으로 예상했다. 하지만 1995년 초 Sun Microsystems는 아직 출시되지 않은[^6] Java 언어에 대한 기습적인 홍보 캠페인[Byous 1998]을 시작했다. Sun과 넷스케이프는 빠르게 협력하여 Java를 넷스케이프 2에 통합하는 계약을 체결했다. 아이크는 넷스케이프 회의에서 Marc Andreessen이 "넷스케이프에 자바가 더해지면 윈도우즈를 죽인다"라는 슬로건을 말했던 것을 회상했다. 1995년 5월 23일 Sun이 Java를 공개한 날, 넷스케이프는 브라우저에서 Sun의 Java 기술을 라이센스할 의도를 발표했다.[Netscape 1995a]

넷스케이프 내부에서는 스크립트 언어를 선택하기 위해 급박한 전략을 수립해야 했고 이런 상황 때문에 Scheme, Perl, Python, Tcl, 그리고 비주얼 베이직을 실행 불가능한 후보로 만들었다. 시장에 출시하기까지의 시간 고려 및 사업적 이해관계로 인해서였다. 넷스케이프와 선의 고위 관리자들, 특히 Marc Andreessen과 선의 Bill Joy는 자바를 보완하는 "작은 언어"[^7]를 설계하고 구현하는 것만이 가능하다고 생각했다.

선과 넷스케이프의 주류에 해당하는 사람들은 간단한 스크립트 언어의 필요성에 대해 의문을 제기했다. Java는 스크립팅에 적합하지 않은가? 하나의 언어만 있는 것보다 왜 2개의 언어가 있는 게 나은지 설명 가능한가? 그리고 넷스케이프가 새로운 언어를 만들 만큼의 충분한 전문성을 갖추고 있는가?

첫 번째 반대는 쉽게 반박되었다. 1995년 봄 당시 Java는 초보자에게 적합한 언어가 아니었다. 메인 프로그램의 코드 본문은 패키지의 클래스^g 선언 내부의 `main`이라는 정적 메서드$^{g}$내에 있어야 했다. 모든 매개변수, 리턴값 그리고 변수에는 정적 타입$^{g}$을 선언해 주어야 했다. 비주얼 C++을 보완하는 비주얼 베이직, 그리고 네이티브 코드 기반의 컴포넌트를 보완하는 여러 유닉스 언어의 경험을 기반으로, Java가 스크립트 언어를 조립하는 `"glue" scripter`들에게 적합한 쉬운 언어가 아님은 명백했다.

두번째 반대는 마이크로소프트의 제품을 인용하는 것으로 극복할 수 있었다. 마이크로소프트는 전문 윈도우 애플리케이션 프로그래머들에게 비주얼 C++을 판매했다. 그리고 아마추어와 파트타임 프로그래머, 디자이너, 회계사 등에게는 비주얼 베이직을 판매했다. 비주얼 C++로 만들어진 컴포넌트들을 덜 숙련된 사람들이 조립하고 조작할 수 있는 스크립트 언어로서였다. "애플리케이션을 위한 비주얼 베이직"이라고 불린 비주얼 베이직 버전은 마이크로소프트 오피스 제품에 통합되어 그 제품들의 사용자 확장과 스크립팅을 지원했다.

처음의 두 가지 반대를 극복한 후 Marc Andreessen은 브라우저의 스크립트 언어의 코드네임으로 "모카(Mocha)"를 제안했다. 아이크에 의하면 이때 언어의 이름을 적절한 때 "Javascript"로 바꾸게 될 거라는 바람이 있었다고 한다. 아무튼 이 Java의 동반자 언어는 "자바처럼 보여야"했고 그럼에도 사용하기 쉬워야 했으며 Java같은 클래스 기반이 아닌 "객체 기반(object-based)"이어야 했다.

아직 마지막 하나의 반대 주장이 남아 있었다. 넷스케이프가 효율적인 스크립트 언어를 만들고 1995년 9월의 넷스케이프 2 베타에 맞게 준비할 수 있을 만큼 충분한 전문성을 갖추고 있는가? 모카를 만드는 것으로 이걸 증명하는 것이 브랜든 아이크의 과제였다.

[^4]: 아이크의 초기 커리어에 대해서는 Coders At Work[Seibel 2009, chapter 4]라는 책이 더 자세히 다루고 있다.
[^5]: Scheme 언어에 대한 언급[Sussman and Steele Jr 1975]
[^6]: Java의 스텔스 알파 릴리즈는 1995년 3월/4월이었다.
[^7]: 존 벤틀리[1986]은 작고 배우기 쉬운 언어를 묘사하기 위한 용어 "little language"를 다음과 같은 의미로 소개했다. "특정 문제 도메인에 특화되어 있으며 전통적인 언어들에서 발견되는 많은 특징들을 포함하지 않는 언어"

## 2.2. 모카의 이야기

Java의 발표가 임박한 상황에서 브랜든 아이크는 시간이 가장 중요하다고 보았다. 그리고 불확실한 가능성보다는 확실하게 보이는 것을 선택하여 1995년 5월의 10일 동안 최초의 모카$^{g}$ 구현을 시제품으로 만들었다.[^8] 이 작업은 실행 가능성을 보여주기 위한 기한에 맞추려고 서둘러 진행되었다. 데모는 최소한의 언어 구현으로 구성되었으며 넷스케이프 2 프리-알파 브라우저에 최소한으로 통합되었다. 

아이크가 만든 프로토타입은 실리콘 그래픽스 인디 유닉스 워크스테이션에서 개발되었다[Netfreak 2019]. 그 프로토타입은 수작업으로 만들어진 렉서와 재귀-하강(recursive-descent) 파서를 사용했다. 파서는 parse tree 대신 바이트코드로 변환된 명령어들을 출력했다. 바이트코드 인터프리터$^{g}$는 간단하고 느렸다.[^9]

바이트코드는 넷스케이프의 LiveWire 서버[^10] 쪽의 요구사항이었다. 그쪽의 개발자들은 모카가 프로토타입이 만들어지기도 전부터 그걸 내장할 것을 기대하고 있었다. 그 팀에 있는 볼랜드의 전 경영진과 엔지니어링 스태프들은 동적인 스크립트 언어의 강력한 지지자였지만, 더 빠른 서버 애플리케이션 로딩을 위해서 소스 파싱보다는 바이트코드를 원했다.

마크 앤드리슨은 모카가 누구든지 HTML 문서 내에서 몇 줄은 바로 쓸 수 있을 정도로 사용하기 쉬워야 한다고 강조했다. 선과 넷스케이프의 고위 관리직들은 모카가 "자바처럼 보여야 한다"고 되풀이해 요구했으며 BASIC과 같은 것을 명백히 배제했다. 하지만 자바처럼 보이는 외관을 가지는 것은 자바와 비슷하게 동작하리라는 기대를 만들었고 이는 객체$^{g}$ 모델의 설계와 boolean, int, double, string과 같은 "원시 타입"의 의미에 영향을 미쳤다.

자바처럼 보이는 것을 제외하면 브랜든 아이크는 대부분의 언어 설계 사양을 자유롭게 선택할 수 있었다. 넷스케이프에 합류한 후 그는 HyperTalk [Apple Computer 1988], Logo [Papert 1980], Self [Ungar and Smith 1987]와 같은 사용하기 쉽고 교육적인 언어들을 탐구했다. 모카가 객체 기반이 되어야 한다는 것은 모두 동의했다. 하지만 클래스는 없어야 했다. 왜냐 하면 클래스를 지원하는 것은 너무 오래 걸릴 뿐더러 클래스를 지원한다면 이미 클래스 모델을 갖추고 있던 자바와 경쟁해야 하는 리스크가 생겼기 때문이다. Self에 대한 존경심으로 아이크는 위임(delegation$^{g}$)을 사용하고 프로토타입 링크를 하나만 갖는 동적 객체 모델을 사용하기로 결정했다. 그는 이것이 구현 시간을 절약할 것이라고 믿었다. 하지만 결국 모카 프로토타입에서는 시간이 없어서 그 방식을 넣을 수 없었다.

객체는 생성자 함수$^{g}$에 new 연산자를 적용하여 생성할 수 있었다. 기본 객체 생성자 함수인 Object는 다른 내장 객체들과 함께 환경에 내장되어 있었다. 각 객체는 0개 이상의 속성으로 구성된다. 각 속성$^{g}$은 이름(또는 property key)과 값으로 구성되며, 이때 값은 함수$^{g}$, 객체 또는 다른 내장 데이터 타입 중 하나일 수 있다. 속성은 아직 사용되지 않은 속성 키에 값을 할당함으로써 생성됩니다. 속성에 대한 접근 제한이나 할당 제한은 없다(역주 : private나 getter 같은 개념을 말하는 듯 하다). 생성자 함수는 초기 속성 집합을 제공할 수 있다. 객체 생성 후에도 추가 속성을 객체에 추가할 수 있다. 이러한 매우 동적인 접근 방식은 특히 LiveWire 팀에게 좋은 반응을 얻었다.

Scheme을 사용하는 매력은 사라졌지만 브랜든 아이크는 여전히 Lisp 스타일의 일급$^{g}$ 함수 개념에 매력을 느꼈다. 클래스가 없어서 메소드를 포함할 수는 없었지만 일급 함수는 Scheme에서 영감을 얻은 용법들을 구현할 수 있는 도구를 제공했다. 최상위 레벨 프로시저, 함수를 인수로 넘기기, 객체의 메소드 그리고 이벤트 핸들러 등이 그렇다. 시간이 부족해서 함수 표현식(람다 표현식$^{g}$이라고도 불린다)의 구현은 연기되었지만 문법에는 예약되어 있었다. 이벤트 핸들러와 객체 메소드는 자바(그리고 C++)에서 가져온 this 키워드를 사용하여 통합되었다. 이 this 키워드는 메소드로서 호출된 함수에 대한 컨텍스트 객체를 나타낸다.

프로토타입은 프로그램을 포함하고 있는 문자열을 파싱하고 실행할 수 있는 eval 함수를 지원했다. 이는 마크 앤드리슨과 초기 넷스케이프 엔지니어들과의 비공식적인 토론에서 동기를 얻은 것이었다.[^11] 여기에 담긴 직관은 동적으로 문자열을 프로그램으로 변환하는 이런 종류의 동적인 프로그래밍이 웹 브라우저와 서버의 몇몇 애플리케이션에서 중요할 거라는 생각이었다.[^12] 하지만 이렇게 eval을 지원하기로 한 결정은 즉각적인 결과를 가져왔다. 몇몇 사용 사례에서는 함수가 Java같은 toString 메서드를 통해서 문자열 형식으로 그 소스코드를 전달할 것을 요구했다. 아이크는 10일간의 스프린트[^13]동안 바이트코드 디컴파일러를 구현하기로 결정했다. 몇몇 필요한 아키텍처를 위해서 소스 코드의 기본 저장소나 보조 저장소에서 복구하는 건 너무 비용이 많이 들 것으로 보였기 때문이다. 이는 윈도우즈 3.1 개인용 컴퓨터에서 특히 그랬다. 이 컴퓨터는 인텔 8086 16비트 세그먼트 메모리 모델에 의해 제한되어 있었고 무제한 또는 큰 인메모리 구조를 위해 오버레이와 수동으로 관리되는 멀티-세그먼트 메모리가 필요했다.

열흘의 프로토타이핑 기간 이후 모카 프로토타입은 전체 넷스케이프 엔지니어링 스태프가 모인 회의에서 공개되었다(그림 2). 이는 성공적이었고 이 성공은 1995년 9월에 첫 베타 릴리즈가 예정되어 있던 넷스케이프 2가 더 완전하고 통합된 버전으로 나올 수 있을 거라는 과도한 낙관주의로 이어졌다. 그해 여름 브랜든 아이크는 모카와 브라우저를 더 완전히 통합하는 것에 주로 초점을 맞췄다. 그러기 위해서는 모카 프로그램이 웹 페이지와 상호 작용할 수 있도록 API를 설계하고 구현해야 했다. 동시에 언어의 프로토타입 구현을 상용 가능한 소프트웨어로 변환하고 초기의 내부 사용자들의 버그 리포트, 변경 제안, 기능 요청에 응답해야 했다.

열흘간 진행된 모카의 창조에 대한 더 많은 내용은 브랜든 아이크가 해당 시절을 이야기한 데에서 찾아볼 수 있다.[Eich 2008c, 2011d; JavaScript Jabber 2014; Walker 2018] 모카의 프로덕션 버전의 소스코드는 인터넷 아카이브에서 볼 수 있다.[Netscape 1997b] 제이미 자윈스키[1999]의 "the netscape dorm"은 그 시절의 넷스케이프에서 소프트웨어 개발자로 일하는 경험에 대한 동시대의 기록이다.


[^8]: 정확한 날짜에 대한 알려진 기록은 없지만 브랜든 아이크는 이것이 5월 6일에서 15일까지였다고 기억하고 있다.
[^9]: 데이터 값$^{g}$을 나타내기 위해서 큰 discriminated union$^{g}$을 사용했으며 메모리 관리에는 레퍼런스 카운팅 기법을 사용했다.
[^10]: 브랜든 아이크는 넷스케이프에서의 첫 달 동안 공식적으로 서버 그룹에서 일했다.
[^11]: 클라이언트와 서버 사이드 둘 모두에서 쓰일 수 있는 2개의 언어를 만든 General Magic에서 일했던 John Giannandrea를 포함한다.
[^12]: 문자열을 동적으로 프로그램으로 변환함으로써, 예를 들어 폼(form)의 부분적인 평가를 하거나 클라이언트에서 제공된 코드를 서버에서 실행하는 걸 지원하도록 할 수 있었다. 이는 Telescript [General Magic 1995] 에이전트와 비슷했다.
[^13]: 1995년의 개발자들은 "스프린트"라는 단어를 쓰지 않았다. 하지만 이 단어는 당시 아이크의 노력을 잘 형상화한다.

# 3. Javascript 1.0과 1.1

넷스케이프 커뮤니케이션즈 주식회사와 썬 마이크로시스템즈는 1995년 12월 4일 JavaScript를 공동 보도 자료를 통해 발표했다[Netscape and Sun 1995; Appendix F]. 보도 자료에서는 JavaScript를 "객체 스크립팅 언어"이며 동적으로 "자바 객체의 속성과 동작을 수정하는" 스크립트를 작성하는 데 사용될 거라고 설명했다. 이것은 "온라인 애플리케이션 개발을 쉽게 하기 위해 존재하는 '자바의 보완재'"으로서의 역할을 할 거라고 했다. 회사들은 자바와 자바스크립트의 유사성이 표면적으로만 비슷했음에도 불구하고 둘 간의 강한 브랜드 연결을 구축하려고 시도했다. 자바와 자바스크립트 간 이름의 유사성과 두 언어들이 밀접하게 관련되어 있다는 암시는 꾸준히 혼동의 원인이 되었다.

![그림 2. 모카 콘솔](./pictures/mocha-console.png)
그림 2. 모카 콘솔. 브랜든 아이크가 만든 모카의 초기 데모에는 SGI 유닉스 워크스테이션에서 실행된 넷스케이프 2 프리알파 버전에서 구동되는 "모카 콘솔" 기능이 있었다. 이 모카 콘솔은 이름 빼고는 본질적으로 바뀌지 않은 채로 넷스케이프 2의 정식 릴리즈에 포함되었다. 이는 윈도우 95에서 실행되는 넷스케이프 2.02의 화면 캡처다. 모카 콘솔은 mocha:를 브라우저 주소 바에 입력하는 것으로 활성화되었다. 정식 버전의 넷스케이프 2에서는 이게 javascript:로 바뀌었지만 mocha:도 여전히 작동했다. 콘솔을 활성화하면 브라우저에서 두 칸으로 이루어진 페이지가 열렸다. 아래 칸의 텍스트 박스에 입력된 모카 표현식은 위 칸의 컨텍스트에서 평가되고 실행되었다. 이 예시는 표현식이 계산된 값을 포함하는 팝업을 표시하기 위해서 내장 alert 함수가 호출되는 것을 보여준다. 원래의 데모 버전에서는 "Javascript Alert" 대신 "Mocha Alert"가 표시되었을 것이다.

---

자바스크립트는 "LiveScript"라는 이름으로 넷스케이프 네비게이트 2.0의 첫 베타 릴리즈의 일부로 들어가면서 1995년 9월 처음 대중에게 공개되었다[Netscape 1995b]. 이후 4번의 베타 릴리즈가 더 진행되었고 1996년 3월 자바스크립트 1.0을 지원하는 넷스케이프 네비게이터 2.0의 정식 버전이 출시되었다. 넷스케이프 엔터프라이즈 서버 2.0도 1996년 3월 [Netscape 1996f]에 출시되었으며, 자바스크립트 1.0을 LiveWire의 서버사이드 스크립팅 컴포넌트에 포함했다.

자바스크립트는 넷스케이프 네비게이터의 상대적으로 작은 기능 중 하나였다. 그래서 자바스크립트의 개발은 1995년 8월의 기능 동결이 요구되었던 네비게이터 2.0의 전체적인 일정에 의해 제약을 받았다. 자바스크립트 1.0의 기능 세트는 본질적으로 당시 8월의 모카 구현에서 작동하거나 거의 작동하는 것들을 골라낸 것이었다. 이 기능 세트는 구상되었던 언어 설계에 비해 불완전했고 아이크가 네비게이터 2.0 릴리즈 과정에서 초기 모카 구현의 버그들을 계속 수정했음에도 불구하고 많은 문제가 있는 버그와 엣지 케이스 동작들을 보였다. 자바스크립트 1.0 릴리즈 직전에 브랜든 아이크의 인터뷰[Shah 1996]를 보면 브랜든 아이크는 자바스크립트가 자바의 부속물이라는 공식 입장과 초기 릴리즈의 급박한 상황을 반복해 말했다.

---

BE(브랜든 아이크): 저는 자바스크립트가 다른 회사들에 의해서도 구현되기를 바랍니다. 저와 빌 조이가 만들고 있는 사양에 기반해서요. 저는 자바스크립트가 작은 언어로 남기를 바라지만 HTML 요소와 거기에 가하는 동작들 그리고 Java applet과 다른 컴포넌트들을 결합하기 위해 쓰이면서 웹에서 범용적으로 사용되기를 바랍니다.

BE: ...제가 아는 한 자바스크립트의 가장 흔한 사용처는 페이지를 조금 더 똑똑하고 생생하게 만드는 건데요. 예를 들어 링크를 클릭하면 그때의 시간에 따라 다른 URL$^{g}$로 간다든지 하는 거요.
...

BE: 자바스크립트는 대부분 저 혼자 만들었기 때문에 넷스케이프 2.0은 짜증나는 작은 버그들이 많이 포함되어 있을 것입니다. 하지만 터널의 끝에는 빛이 있겠죠. 저는 모든 큰 버그들에 대해서는 해결책을 찾았기를 바랍니다. 다른 개발자들과 버그와 그 해결책을 찾는 데에 많은 시간을 썼거든요. 
저는 2.1버전을 마무리하고 있는데요. 버그를 고치고 기능을 추가하고 모든 플랫폼에서 자바스크립트가 일관되게 동작하도록 노력하고 있습니다. 2.1이 언제 출시될지는 모르겠지만, 저희는 빠르게 작업하고 있기 때문에 내년 봄 전에는 출시될 거라고 내기라도 걸 수 있습니다.

---

자바스크립트 1.0 [Netscape 1996d]는 산술 연산, 문자열, 불린값, 일급 함수 그리고 객체 자료형을 지원하는 간단한 동적 타입$^{g}$ 언어였다. 문법적으로 보면 자바스크립트는 자바처럼 C 계열에 속했다. C에서 가져온 제어 흐름 문법과 C의 산술 연산자 대부분을 포함하는 표현식 구문을 가지고 있었다. 자바스크립트 1.0에는 작은 내장 함수 라이브러리도 있었다. 자바스크립트 1.0 소스 코드는 보통 HTML 파일에 직접 포함되었다. 하지만 내당 라이브러리에는 자바스크립트의 문자열에 담긴 자바스크립트 소스 코드를 파싱하고 평가할 수 있는 eval 함수도 포함되어 있었다. 자바스크립트 1.0은 매우 간결한 언어였다. 그림 3은 자바스크립트 1.0에 없었던 몇몇 문법들의 요약인데, 이는 현대 자바스크립트 프로그래머에게는 매우 놀라울 수도 있다.

1996년 초, 이후 1996년 8월 출시되어 넷스케이프 네비게이터 3.0이라 불릴 제품에 대한 작업이 "아틀라스" [Netscape 1996g]라는 코드네임 하에 시작되었다. 브랜든 아이크는 1995년 8월 네비게이터 2.0에서 미완성이거나 누락되었던 기능들에 대한 작업을 다시 시작할 수 있었다. 자바스크립트의 초기 정의와 개발은 네비게이터 3.0에 담긴 자바스크립트 1.1 [Netscape 1996a,e]이 출시됨으로써 완성되었다. 다음 섹션들은 자바스크립트 1.0/1.1 언어의 설계에 대한 개요를 제공한다.

## 3.1 자바스크립트 문법

JavaScript 1.0의 문법은 C언어의 문장 구문[ANSI X3 1989]과 AWK$^{g}$[Aho 등 1988]에서 영향을 받은 몇 가지 장식을 직접적인 기반으로 모델링되었다. 스크립트는 선언(declaration)과 문장(statement)의 연속이다. C와 달리 자바스크립트의 문장은 함수 내부에서만 발생해야 한다는 제한이 없다. JavaScript 1.0에서 스크립트의 소스 코드는 HTML 문서 내에 포함된 `<script></script>` 태그로 둘러싸여 있다.

C의 영향을 받은 JavaScript 1.0의 문장들에는 이런 것이 있다. 표현식, if 조건문, for과 while 반복문, 비순차적인 흐름 제어를 위한 break, continue, return 문, `{}`로 묶인 문장들을 하나의 문장처럼 사용할 수 있게 하는 문장 블록, if, for, while 문은 복합 문장이다[^14]. JavaScript 1.0은 C의 do-while 문, switch 문, 문장 레이블(statement label), goto 문을 포함하지 않았다.

Javascript 1.0은 C의 문법을 기본으로 했는데, 거기에 객체 자료형의 속성에 접근하기 위한 2가지 복합 문장을 새로 추가했다. AWK에서 영향을 받은 `for-in` 문은 객체의 속성 키$^{g}$를 반복한다. with[^15]문의 본문 내에서는 지정한 객체의 속성에 접근할 때 마치 해당 속성명이 선언된 변수인 것처럼 접근할 수 있다. 객체의 속성은 동적으로 추가될 수 있으므로(이후 버전에서는 삭제됨) `with`문의 본문 내에서 코드 실행이 진행됨에 따라 보이는 변수 바인딩$^{g}$이 바뀔 수 있다.

Javascript의 선언은 C나 Java의 선언 스타일을 따르지 않는다. Javascript는 동적 타입 언어이다. 그리고 선언임을 인식하기 위한 문법적 접두사로 사용할 수 있는 타입명도 지원하지 않는다. 대신 Javascript 선언은 키워드가 접두사로 붙는다. Javascript 1.0의 선언에는 2가지 형태의 선언이 있는데 `function` 선언과 `var`선언이다. `function` 선언[^16] 문법은 AWK에서 직접적으로 가져왔다. `function`선언은 호출 가능한 단일 함수를 정의하는데, 이름, 형식 매개변수, 그리고 함수 본문을 정의한다. `var`선언은 하나 이상의 변수 바인딩을 도입하고 변수에 값을 할당할 수 있다. 값 할당은 필수는 아니다. 모든 var 선언은 문장으로 취급되며 블록 문장 내를 포함하는 어떤 문장 맥락에서도 발생할 수 있다. Javascript 1.0/1.1에서 `function`으로 시작되는 함수 선언은 스크립트의 최상위에서만 발생할 수 있으며 중첩된 함수 선언을 포함할 수 없었다. var 선언은 함수 본문 내에서 발생할 수 있으며, 이러한 선언으로 정의된 변수는 함수의 지역 변수이다.

C와 달리 Javascript 1.0에서 문장 블록, 즉 중괄호로 구분되는 블록들은 선언 스코프를 만들지 않는다. 함수 본문을 구분짓는 중괄호 블록 내의 var 선언은 전체 함수 본문에서 지역 변수로 동작한다. 함수 외부의 블록에 있는 var 선언은 전역 스코프$^{g}$를 가진다. 범위 내에 function이나 var 선언이 없는 변수명에 할당할 경우 그 이름의 전역 변수가 암시적으로 생성된다. 이 동작은 이미 선언된 변수의 이름을 잘못 타이핑해도 에러가 뜨는 대신 조용히 새 변수가 생성되도록 하기 때문에 버그의 큰 요인이 되었다.

Javascript와 전통적인 C 문법의 주요한 차이 중 하나는 문장의 끝에 붙이는 세미콜론을 Javascript가 처리하는 방식이다. C는 세미콜론을 문장 종결에 필수로 취급하는데, Javascript는 세미콜론이 한 줄의 마지막 significant character일 때 문장 종결을 위한 세미콜론을 생략할 수 있도록 허용한다. 이 동작의 정확한 규칙은 Javascript 1.0 문서에 포함되어 있지 않았다. Netscape 2.0 핸드북은 여러 Javascript 문장 형태를 설명할 때 세미콜론을 제대로 보여주지 않았다. 그냥 이렇게만 썼다. "하나의 문장이 여러 줄에 걸쳐 있을 수 있다. 그리고 여러 문장이 하나의 줄에 있을 수 있는데 이럴 때 각 문장은 세미콜론으로 구분된다[Netscape 1996d]." 세미콜론을 쓰지 않는 코딩 스타일은 핸드북의 Javascript 코드 예제에서 사용된 표준이었다.

```js
var a, x, y
var r=10
with (Math) {
  a = PI * r * r
  x = r * cos(PI)
  y = r * sin(PI /2)
}
```

세미콜론 없이 Javascript 코드를 작성할 수 있는 건 자동 세미콜론 삽입(Automatic Semicolon Insertion, ASI)덕분이다. ASI는 Javascript 프로그래머들 사이에서 여전히 논쟁의 대상이다. 프로그래머들의 상당한 수가 여전히 세미콜론 없이 코드를 작성하는 스타일을 선호하며, 다른 프로그래머들은 ASI를 사용하지 않고 세미콜론을 붙이는 것을 선호한다.

## 3.2. 자료형과 표현식

JavaScript 1.0/1.1은 5가지 기본 데이터 타입이 있는 동적 타입 언어였다. 그 5가지 타입은 숫자, 문자열, 불린, 객체, 함수였다. 여기서 동적 타입이라 함은 런타임의 타입 정보가 변수같은 값 컨테이너가 아니라 각 데이터와 관련되어 있다는 것을 뜻한다. 런타임 타입 검사는 각 연산이 그것을 지원하는 데이터 값에만 적용되도록 한다.

불린, 문자열, 숫자는 변경 불가능한 값이다. 불린 타입은 true와 false라는 두 가지 값이 있다. 문자열 값은 8비트 문자 코드로 이루어진 변경 불가능한 시퀀스다. 유니코드는 지원되지 않는다. 숫자 타입은 IEEE 754 [IEEE 2008]의 double 정밀도의 64비트 부동소수점 값 전체로 구성되며, 전통적인 NaN 값만 예외다. 일부 연산은 부호 없는 32비트 정수와 부호가 있고 2의 보수 형식으로 나타나는 정수에 해당하는 숫자 값을 특별히 다룬다. Mocha는 내부적으로는 이런 정수값을 다르게 표현했지만 공식적으로는 하나의 숫자 자료형만 있었다.

Javascript 1.0에는 유용한 데이터 값이 없음을 나타내는 데 쓰이는 2가지 특별한 값이 있었다. 초기화되지 않은 변수는 특별한 값 undefined[^17]로 설정되었다. 프로그램이 객체의 존재하지 않는 속성 키에 액세스하려고 할 때도 이 값이 반환되었다. Javascript 1.0에서는 초기화되지 않은 변수를 선언하고 접근함으로써 undefined 값에 접근할 수 있었다. null 값은 객체가 있을 것으로 예상되는 맥락에서 "객체 없음"을 나타내기 위해 만들어졌다. 이는 Java의 null 값에 기반을 두고 있으며, Java로 구현된 객체와 Javascript의 통합을 용이하게 했다. 두 유사하지만 차이점도 많은 값의 존재는 Javascript의 역사 동안 많은 프로그래머들에게 혼란을 주었다. 주어진 상황에서 둘 중 어떤 것을 사용해야 할지 확신하지 못하는 프로그래머들이 많았다.

Javascript 1.0의 표현식 문법은 C에서 가져왔으며 거의 동일한 연산자와 연산자 우선순위 규칙을 가진다. 몇 가지 빠진 부분도 있기는 한데 C의 포인터와 타입 관련 연산자, 그리고 단항 + 연산자이다. 이항 + 연산자는 숫자 덧셈 연산과 문자열 연결 2가지로 오버로딩되어 있다. 시프트 연산자와 비트 논리 연산자는 부호 있는 32비트 2의 보수 형식 정수의 비트 레벨 인코딩에 작용한다. 필요한 경우 피연산자는 정수가 되도록 끝을 자르고 32비트 값으로 모듈로 연산된다. >> 연산자는 32비트 정수 값의 부호를 보존하는 오른쪽 시프트를 수행한다. 그리고 Javascript는 Java에서 가져온 >>> 연산자를 추가했다. 이 연산자는 부호 없는 오른쪽 시프트를 수행한다.

JavaScript 1.1에는 delete, typeof, void 연산자가 추가되었다. Javascript 1.1에서 delete 연산자는 변수나 객체 속성을 피연산자로 받아서 그 값을 null로 설정했다. typeof 연산자는 피연산자의 원시 타입을 식별하는 문자열을 반환했다. 가능한 값으로는 "undefined", "object", "function", "boolean", "string", "number" 그리고 호스트 정의 객체를 식별하기 위해 구현체에서 정의한 값이 있었다. 놀랍게도 typeof null은 "null"이 아니라 "object" 문자열을 반환한다. 이는 모든 값이 객체이고 null이 본질적으로 "객체 없음"을 나타내는 객체인 Java와 일관성이 있다고 할 수도 있다. 그러나 Java는 typeof 연산자와 같은 기능을 하는 무언가가 없으며 초기화되지 않은 변수의 기본값으로 null을 사용한다. 브랜든 아이크는 typeof null의 결과는 처음의 모카 구현에 있었던 leaky abstraction$^{g}$의 결과였다고 회상한다. null의 런타입 값은 객체 값의 사용된 내부적인 태그 값과 같은 태그 값을 갖도록 인코딩되었고, 따라서 내부 태그 값을 확인하던 typeof 연산자의 당시 구현은 어떤 특별한 검사 로직 없이 "object"를 반환했던 것이다. 이는 객체의 속성에 접근해서 그 값을 사용하기 전 해당 값이 실제로 객체인지 테스트하려고 했던 Javascript 프로그래머들에게 큰 불편을 주었다. typeof의 결과가 "object"인 것을 테스트하는 것만으로는 null을 제대로 걸러낼 수 없었고 null의 속성에 접근하려고 시도하는 것은 런타임 오류를 발생시켰기 때문이다.

void 연산자는 단순히 피연산자를 평가한 다음 undefined를 반환한다. undefined에 접근하는 하나의 일반적인 방법은 void 0을 사용하는 것이다. void 연산자는 원래 클릭했을 때 Javascript 코드를 실행하는 HTML 하이퍼링크를 정의하기 위해 도입되었다. 예를 들어 이런 식이다.

```html
<a href="javascript:void usefulFunction()">Click to do something useful</a>
```

href 속성$^{g}$의 값은 URL이어야 하는데 javascript:는 브라우저에 의해 인식되는 특별한 URL 프로토콜이다. 이는 뒤따르는 것을 JavaScript 코드로 평가하고, 그 결과를 문자열로 변환하여 일반 href URL을 사용하여 가져온 응답 문서인 것처럼 사용하라는 의미이다. `<a>` 요소는 그 응답 문서가 undefined가 아닌 경우 그것을 처리하려고 시도할 것이다. 그런데 일반적으로 웹 개발자는 링크가 클릭되었을 때 Javascript 표현식이 그냥 실행되고 평가되기만 원하지 그 결과를 사용하고 싶어하지는 않는다. void 연산자를 표현식 앞에 붙이는 것은 `<a>`요소에 의한 추가 처리를 방지하고 개발자가 원하는 대로 표현식이 평가만 되도록 해주었다.

![그림 4](./pictures/figure4.png)

그림 4. Eich와 McKinney에 의해 발표된 Javascript 1.1 타입 변환표[1996, page 23]. Javascript 1.1 예비 사양에 있었다. 최종적으로 표준화된 타입 변환 규칙은 약간 다르다. 이 그림은 약간의 인쇄상의 차이가 있지만 원본 표의 복사본이다. 원본에는 각주 3이 없었다.

C와 JavaScript 표현식 사이의 가장 중요한 차이점은 JavaScript 연산자는 자동으로 피연산자를 연산자가 받을 수 있는 자료형으로 암묵적 형변환을 한다는 것이다. Javascript 1.1은 이렇게 임의의 객체를 숫자나 문자열 값으로 변환하는 설정 가능한 메커니즘을 추가했다. 그림 4는 Javascript 1.1의 암묵적 형변환 규칙을 요약한다.

## 3.3. 객체(Objects)

```js
// using Object constructor
var pt = new Object;
pt.x=0;
pt.y=0;

// using custom constructor
function Point (x,y) {
this.x = x;
this.y = y;
}
var pt = new Point (0, 0);
```

그림 5. Javascript 1.0의 객체 생성을 위한 다른 방법들. Object 생성자로 객체를 생성한 뒤 속성을 추가할 수도 있고 생성자 함수를 만들어서 객체가 만들어지는 동안 속성을 추가할 수도 있다.
---
Javascript 1.0의 객체는 "속성(property)"라 불리는 원소들로 이루어진 연관 배열이다. 각 속성은 문자열로 된 키와 값을 가지고 값은 Javascript의 어떤 데이터 타입이든 될 수 있다. 속성은 동적으로 추가될 수 있다. JavaScript 1.0/1.1은 객체에서 속성을 제거하는 방법을 제공하지 않았다.

키 문자열이 식별자 이름에 대한 문법 규칙을 준수할 시 해당 속성은 점 표기법을 통해서 접근할 수 있다. 예를 들어서 `obj.prop0`과 같이 할 수 있다. 식별자가 아닌 키를 가진 속성을 포함한 모든 속성은 대괄호 표기법으로 접근할 수 있다. 이 표기법을 사용하면 대괄호로 둘러싸인 표현식은 평가되고 문자열로 변환되어 속성의 키로 사용된다. 예를 들어 obj["prop"+n]은 n의 값이 0일 때 obj.prop0과 동일하다. 존재하지 않는 속성에 값을 할당하면 새로운 속성이 생성된다. 만약 존재하지 않는 속성의 값에 접근하려고 하면 보통 undefined가 반환된다. 하지만 Javascript 1.0/1.1에서는 대괄호 표기법을 사용해 존재하지 않는 객체의 속성 값에 접근했으며 사용한 속성 키가 음이 아닌 정수의 문자열 표현이었을 경우 null이 반환되었다.

속성은 데이터 저장소로 사용될 수도 있고 객체의 동작을 구현하는 데에 사용될 수도 있다. 그 값이 함수인 속성은 객체의 메서드로서 호출될 수 있다. 객체의 메서드로 호출된 함수는 키워드 this와의 동적 바인딩을 통해 자신을 호출한 객체 그 자신에게 접근할 수 있다(§3.7.4).

객체는 내장 함수나 사용자 정의 함수에 new 연산자를 적용하여 생성된다. 이런 용도로 사용되기 위해 만들어진 함수를 "생성자(constructor)"라고 한다. 생성자는 일반적으로 새로운 객체에 속성을 추가한다. 이 속성들은 저장할 데이터 혹은 메서드이다. 내장 생성자 Object는 초기에 속성이 없는 새로운 객체를 생성하는 데에 사용될 수 있다. 그림 5는 Object 생성자나 사용자 정의 생성자 함수가 새로운 객체를 생성하는 방법을 보여준다.

JavaScript 1.0에는 또한 내장 Array 생성자가 있다. 하지만 Array 생성자로 생성된 객체와 Object 생성자로 생성된 객체 사이의 유일한 차이점은 객체에 표시되는 디버깅 문자열뿐이다. JavaScript 1.0의 Array 생성자로 생성된 객체는 length 속성을 가지고 있지 않았다.

정수값을 키로 사용하는 속성들을 생성함으로써 어떤 객체에 대해서든 배열과 유사한 인덱싱 동작을 할 수 있다. 이런 객체는 정수가 아닌 키를 가진 속성들도 가질 수 있다.

```js
var a = new Object; // or new Array
a[0] = " zero ";
a[1] = " one";
a[2] = " two";
a. length = 3;
```

---

```js
// define functions to be used as methods
function ptSum(pt2) {
    return new Point(this.x + pt2.x, this.y + pt2.y)
}

function ptDistance(pt2) {
    return Math.sqrt(Math.pow(pt2.x - this.x, 2) + Math.pow(pt2.y - this.y, 2));
}
// define Point constructor
function Point(x, y) {
    // create and initialize a new object 's data properties
    this.x = x;
    this.y = y;
    // add methods to each instance object
    this.sum = ptSum;
    this.distance = ptDistance;
}
var origin = new Point(0, 0); // create a Point object
```

그림 6. Javascript 1.0에서 추상화된 Point 객체를 생성한다. 각 인스턴스는 각각의 메서드 속성들을 가지고 있다.

---

Javascript 1.0은 상속$^{g}$의 개념이 없다. 프로그램은 각각의 새로운 객체에 모든 속성을 개별적으로 추가해야 한다. 이는 일반적으로 프로그램에서 사용하는 각 "클래스" 객체에 대한 생성자 함수를 정의하는 방식으로 이루어진다. 그림 6은 Javascript 1.0을 사용하여 작성된 간단한 Point 추상화 정의를 보여준다. 이 예제에서 중요한 점은 다음과 같다.

- 각 메서드는 전역 함수로 정의되어야 한다. 이 함수들은 다른 추상화 객체의 메서드 함수를 정의하는 데에 사용되는 이름과 충돌하지 않을 가능성이 있는 이름을 가져야 한다(예: ptSum, ptDistance).
- 객체가 생성되는 시점에 객체 속성들은 각 메서드를 위해 생성된 전역 함수로 초기화된 값으로 생성되어야 한다.
- 메서드는 선언된 전역 이름(ptDistance)보다는 객체 속성 이름(origin.distance)을 사용하여 호출된다.

Javascript 1.1에서는 각각의 새로운 인스턴스에 직접 메서드 속성을 생성할 필요가 없어졌다. 1.1부터는 생성자 함수 객체의 `prototype`이라는 속성을 통해서 생성자 함수 인스턴스의 프로토타입$^{g}$ 객체를 연결할 수 있게 되었다. JavaScript 1.1 가이드 [Netscape 1996e]는 `prototype`을 "지정된 타입의 모든 객체에 의해 공유되는 속성"으로 설명한다. 이건 모호한 설명이고, 다음과 같이 더 잘 표현할 수 있다. "해당 생성자에 의해 생성된 모든 객체에 의해 공유되는 속성을 가진 객체"라고 말이다. 이런 공유 메커니즘은 더 자세히 설명되지는 않았지만 다음과 같은 프로토타입 객체의 속성들을 관찰할 수 있다.

- 해당 객체를 생성한 생성자 함수의 `prototype` 객체에 정의된 속성 이름에 접근하면 생성자 함수의 `prototype` 객체의 해당 속성 값이 반환된다.
- 프로토타입 객체의 속성을 추가하거나 수정하는 것은 기존에 해당 prototype 속성을 가진 생성자 함수에 의해 만들어진 객체에 즉시 반영된다.
- 객체의 생성자 함수의 `prototype`에 이미 정의되어 있는 속성과 같은 이름의 속성에 값을 할당하면 객체의 속성 값이 생성자 함수의 `prototype`에 정의된 속성 값을 덮어씌운다(shadow$^{g}$[^18]).

내장 Object.prototype 객체의 속성은 객체 또는 객체의 프로토타입 객체에 의해 덮어씌워지지 않는 한 모든 객체에서 접근 가능하다.

[^18]: 프로토타입의 속성을 덮어씌우는(over-ride)새로운 속성을 만드는 것

```js
// define functions to be used as methods
function ptSum(pt2) {
    return new Point(this.x + pt2.x, this.y + pt2.y)
}

function ptDistance(pt2) {
    return Math.sqrt(Math.pow(pt2.x - this.x, 2) + Math.pow(pt2.y - this.y, 2));
}
// define Point constructor
function Point(x, y) {
    // create / initialize a new object's data properties
    this.x = x;
    this.y = y;
}
// add methods to shared prototype object
Point.prototype.sum = ptSum;
Point.prototype.distance = ptDistance;
var origin = new Point(0, 0); // create a Point object
```

그림 7. Javascript 1.1에서 추상화된 Point 객체를 생성한다. 각 Point 인스턴스 객체는 직접 속성들을 정의하는 대신 `Point.prototype` 객체에서 메서드 속성들을 상속받는다.

---

그림 7은 그림 6에서 했던 간단한 Point 추상화를 Javascript 1.1에서 다시 정의한 것이다. 이는 메서드가 각 인스턴스 객체에서 반복적으로 정의되는 것과 달리 프로토타입 객체에 한 번만 정의된다는 점이 다르다. 프로토타입 속성을 통해서 객체에서 접근할 수 있는 속성은 상속된 속성$^{g}$이라고 한다. 객체에 직접 정의된 속성은 자체 속성$^{g}$이라고 한다. 자체 속성은 동일한 이름의 자체 속성을 덮어씌운다.

프로토타입 객체 속성은 보통 메서드다. 이 경우 생성자를 통해 제공된 프로토타입 객체는 C++의 vtable이나 Smalltalk의 MethodDictionary와 같은 역할을 하여 객체들의 집합과 공통의 행동을 연관시킨다. 생성자 함수는 본질적으로 클래스 객체의 역할을 하고 프로토타입은 클래스 인스턴스들에게 공유되는 메서드들의 컨테이너와 같다. 이것은 Javascript 1.1의 객체 모델에 대한 합리적인 해석이지만 유일한 해석은 아니다.

생성자 함수의 `prototype` 이라는 속성의 작명은 브랜든 아이크가 다른 객체 모델을 염두에 두었다는 명백한 단서이다. 그 모델은 Self 프로그래밍 언어에 의해 영감을 받았다[Ungar and Smith 1987]. Self에서는 새로운 객체를 만들 때 일부 객체 카테고리의 프로토타입 객체를 복제하여 만든다. 각각의 복제본은 프로토타입 객체를 참조하는 부모 링크를 가지고 있어서 프로토타입이 그 복제본들에게 공통적으로 제공하고자 하는 기능들을 제공할 수 있었다. Javascript 1.1 객체 모델은 Self의 모델의 변형이라고 할 수 있다. 프로토타입 객체는 생성자 함수를 통해서 간접적으로 접근되고 new 연산자는 프로토타입에서 새로운 인스턴스를 복제한다. 복제된 인스턴스는 프로토타입 객체의 속성들을 상속$^{g}$받아서 공통 기능으로 사용할 수 있다. 일부 Javascript 프로그래머들은 이 메커니즘을 "프로토타입 상속$^{g}$"이라고 부른다. 이것은 위임의 한 형태이다. 일부 Javascript 프로그래머들은 Java와 다른 많은 객체지향 언어들에서 사용되는 상속 스타일을 가리키기 위해 "전통적인 상속(classical inheritance)$^{g}$"이라는 중의적 표현을 사용한다.

JavaScript 1.1 문서 [Netscape 1996e]는 이러한 객체 모델 중 어느 것도 완전히 설명하지 않는다. 그 문서는 1995년 12월 넷스케이프와 선의 보도자료와 일관성 있는 마케팅 전략을 유지했다. Javascript는 추상화된 진짜 객체 정의(클래스 정의)는 Java로 쓰여질 때 그 객체들 간의 상호작용을 위한 스크립트 언어로 포지셔닝되었다. Javascript 고유의 객체 추상화 기능은 별로 주목을 끌지 않고 잘 문서화되지 않은 보조 기능으로 제한되었다.

## 3.4. 함수 객체(Function Objects)

Javascript 1.0/1.1의 함수 정의는 호출 가능한 함수를 만들고 이름을 지정한다. Javascript의 함수는 일급 객체 값이다. `function` 키워드 선언에 주어진 이름은 최상위 스코프에서의 `var` 선언과 같이 전역 변수를 정의한다. 그 값은 함수 객체이며 변수에 할당되거나 그 값은 함수 객체이며 변수에 할당되거나, 속성 값으로 설정되거나, 함수 호출에서 인수로 전달되거나, 함수의 반환값으로 쓰일 수 있다. 함수는 객체이기 때문에 속성을 가질 수도 있다. 다음 예시는 함수 객체에 속성을 추가하는 방법을 보여준다.

```js
function countedHello() {
    alert("Hello , World !");
    countedHello.callCount++; // increment this function's callCount property
}

countedHello.callCount = 0; // associate counter with function and initialize
for (var i = 0; i < 5; i++) countedHello();
alert(countedHello.callCount); // displays : 5
```

함수는 형식 매개변수 목록과 함께 선언된다. 하지만 정의와 함께 선언된 매개변수 목록의 크기는 실제로 함수를 호출할 때 전달될 수 있는 인수의 갯수를 제한하지는 않는다. 만약 함수 정의에 선언된 형식 매개변수보다 적은 인수로 함수를 호출하면 전달되지 않은 매개변수는 undefined로 설정된다. 형식 매개변수보다 많은 인수로 함수를 호출하면 추가 인수는 평가되지만 그 값을 매개변수 이름을 통해서 사용할 수는 없다. 그러나 함수 본문이 실행되는 동안 함수 객체의 `arguments` 속성 값을 통해 인수들을 담은 유사 배열 객체를 사용할 수 있다. 함수 호출 시 전달된 모든 실제 인수는 `arguments` 객체의 정수 키 속성을 통해서 사용할 수 있다. 이를 통해 가변 갯수의 인수들을 처리할 수 있는 함수를 작성할 수 있다.

## 3.5. 내장 라이브러리(Built-in Library)

![그림 8](./pictures/figure8.png)

그림 8. Javascript 1.0/1.1의 호스트-독립적인 내장 라이브러리

---

JavaScript 1.0은 내장 함수, 객체, 생성자들의 라이브러리를 가지고 있었다. 이 라이브러리는 소수의 일반 목적 객체[^19]들과 함수들, 그리고 더 많은 호스트별 객체와 함수들을 정의한다. 넷스케이프 네비게이터의 경우 호스트 객체$^{g}$는 현재 HTML 문서의 일부 모델을 제공했다. 이 API들은 결국 '문서 객체 모델(Document Object Model, DOM) 레벨 0' [Koch 2003; Netscape 1996b]으로 알려지게 된다. 넷스케이프 엔터프라이즈 서버의 경우 호스트 객체는 클라이언트/서버 통신, 클라이언트와 서버 세션의 상태 관리, 파일 및 데이터베이스 접근을 지원했다. 서버 호스트 객체에 대한 이러한 설계는 넷스케이프 서버 제품 외에는 널리 채택되지 않았다.

Javascript의 초기 설계는 대부분 브라우저 플랫폼에서 필요로 하는 것들에 의해 주도되었다. 초기 Javascript 버전의 넷스케이프 문서는 어떤 라이브러리 요소가 호스트 환경에 의존적이고 어떤 라이브러리 요소가 호스트 환경에 독립적인지 명확히 구분하지 않았다. 그러나 DOM과 다른 브라우저 플랫폼 API의 설계, 진화, 표준화는 각각의 중요한 이야기를 가지며 그 자체로서의 역사를 가진다. 이 문서는 Javascript의 전체적인 설계와 관련되어 있을 경우에만 브라우저 관련 주제들을 언급한다.

Javascript 1.0은 딱 2가지의 일반 목적 객체 분류를 가지고 있었다. `String`과 `Date`였다. 그리고 일반적으로 사용되는 수학의 상수와 함수들을 정의한 싱글톤 전역 객체 Math도 있었다. 또 접근 방법을 알고 있을 경우 활성화되지 않았거나 불완전하게 구현된 여러 클래스의 생성자들도 Javascript 1.0 프로그램에서 접근할 수 있었다. Javascript 1.1은 이런 기능들의 구현을 완성하고 문서화했다. 그림 8은 Javascript 1.0과 1.1에서 정의된 호스트 독립적인 클래스들을 요약해 보여준다.

[^19]: Javascript에는 객체 추상화 메커니즘을 위한 공식적인 명명이 없었다. 그래서 Javascript 내장 라이브러리에서 지원하는 특정 종류의 객체에 대해 이야기하기 쉽지 않다. JavaScript 문서에서는 "타입", "객체", "생성자", "클래스"와 같은 다양한 용어로 이런 추상화 객체를 이야기했다. 이 문서의 나머지 부분에서는 공통된 표현과 메서드를 공유하는 Javascript 객체 집합을 부르기 위해 첫 글자가 대문자인 `Class`라는 용어를 사용하겠다. 이는 실제 객체 정의의 형태와는 관계없이 적용된다.

---

`String` 클래스는 `length` 속성과 6개의 일반 메서드를 제공한다. 이 메서드들은 불변의 문자열 값들에 작용하며 적절한 경우 새로운 문자열 값을 반환한다. JavaScript 1.0의 `String` 클래스는 또한 문자열 값을 다양한 HTML 태그로 감싸는 열세 개의 메서드를 포함gksek. 이는 Javascript 1.0/1.1에서 호스트 의존적 기능과 일반 목적 기능 사이의 유동적인 경계를 보여주는 예시이다. Javascript 1.0은 전역 `String` 생성자 함수를 제공하지 않는다. 모든 문자열 값은 문자열 리터럴이나 연산자 혹은 내장 함수를 통해서 생성된다. Javascript 1.1에서 전역 `String` 생성자와 `split` 메서드가 추가되었다.

`Date` 클래스는 달력 날짜와 시간을 나타내기 위해 쓰인다. Javascript 1.0의 `Date`는 Java 1.0의 `java.util.Date` 클래스를 버그까지도 그대로 옮긴 것이었다[Gosling et al. 1996]. 이는 1970년 1월 1일 GMT 00:00:00을 기준으로 시작하는 밀리세컨드 단위의 시간 값을 사용하는 것, 다른 날짜 관련 값들과 달리 월을 나타내는 값을 0-11로 번호매기는 것, 자바 설계에 있었던 2000년 문제 등을 포함한다. 이런 설계 결정은 Java와의 호환성 요구 사항에 영향을 받았다. Java의 `java.util.Date`를 옮겨올 때 빠진 것은 equals, before, after뿐이었다. 이들은 Javascript의 자동 형변환으로 인해 숫자 관계 연산자를 Date 객체에 직접 사용할 수 있었기 때문에 필요없어서 제외되었다.

Date는 Object를 제외하면 Javascript 1.0에서 유일하게 사용 가능한 내장 생성자 함수였다. Date는 또 클래스 인스턴스의 메서드 외에 생성자 객체에 메서드를 노출하는 유일한 클래스였다. 브라우저별 클래스 중 어떤 것도 생성자 함수를 노출하지 않았다.

내장 라이브러리 객체와 호스트 제공 객체의 일부 속성은 Javascript 프로그래머가 직접 정의한 속성(사용자 정의 속성)은 가질 수 없는 특징들을 가지고 있다. 예를 들어 내장 객체의 메서드 속성은 for-in 문에 의해 열거되지 않는다. 일부 속성은 delete 연산자를 써도 무시되거나 읽기 전용 값이다. 내장 객체의 일부 속성에 접근하거나 속성을 수정하는 것은 사이드 이펙트를 가진 특별한 동작을 유발한다.

JavaScript 1.1은 사용 가능한 Array 클래스를 추가했다. Array 생성자는 0에서 시작하는 정수 인덱스를 가지며 서로 다른 여러 종류의 값들로 이루어진 벡터와 같은 객체를 생성한다. 배열의 각 요소는 정수 인덱스의 문자열 표현(역주: `'0'`, `'1'`과 같은)을 키로 가지는 객체 속성으로 표현된다. 배열 객체는 또한 생성자에 의해 값이 초기화되는 `length` 프로퍼티를 가지고 있다. `length` 속성의 값은 현재 `length` 값보다 크거나 같은 요소 인덱스에 접근할 때마다 업데이트된다. 따라서 배열 객체의 요소 수는 동적으로 증가할 수 있다.

## 3.6. 실행 모델(Execution Model)