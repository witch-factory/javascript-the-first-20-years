# Part 2: 표준을 만들다(Creating a Standard)

# 7. 장소 찾기(Finding a venue)

1995년 모카 프로젝트가 시작했을 때도 표준이 필요하다는 것은 이미 명백했다. 서로 다른 웹 브라우저들에서 웹 페이지들이 호환될 수 있도록 하기 위해서였다. 이는 넷스케이프와 선의 Javascript 발표[1995]에서 공식적으로 인정되었다.

넷스케이프와 선은 Javascript를 인터넷의 스크립트 언어 표준으로 만들기 위해 W3 Consortium (W3C)와 Internet Engineering Task Force (IETF)에 Javascript를 제안했다.

하지만 W3C나 IETF 모두 벤더 독립적인 Javascript 사양을 만드는 데에 적합한 장소는 아니었다. IETF는 프로그래밍 언어보다는 인터넷 프로토콜과 데이터 포맷에 더 초점을 맞추고 있었다. W3C는 새로운 조직이었는데 그곳의 기술적인 대표단은 웹 기술 생태계에 새로운 명령형 프로그래밍 언어를 추가하는 것에 관심이 없었다. 버너스 리와 협업한 로버트 카이유는 인터뷰에서 이렇게 회상했다. [Wikinews 2007]

---

나는 프로그래밍 언어를 만들어야 한다고 확신했다. 하지만 팀(버너스 리) 등의 개발자들은 매우 반대했다. 그건 완전히 선언적으로 남아 있어야 했다.

---

1996년 초에 브라우저 기술은 "인터넷 시간"[^30] [Iansiti and MacCormack 1997]에 따라서 빠르게 진행되고 있었다. 하지만 언어 표준화는 느리고 자주 논쟁이 있기로 유명했다. 마이크로소프트가 브라우저 경쟁에 진지해지면서, 넷스케이프와 선은 마이크로소프트가 웹 스크립팅 표준의 개발을 주도하려 하는 것, 그리고 표준의 초점을 다시 비주얼 베이직 기반 언어로 맞추려는 것을 우려했다. 그래서 1996년 봄 넷스케이프와 선은 Javascript 표준을 보호하면서 빠르게 초안을 만들 수 있는 공인된 표준 개발 조직을 찾아야 했다. 그 조직은 마이크로소프트의 참여는 있지만 지배는 없어야 했다. 넷스케이프에서 일하던 표준 전문가 칼 카길은 Ecma International의 사무총장인 얀 반 덴 벨드를 알고 있었고, 자바스크립트 표준화를 Ecma 쪽으로 유도했다. Ecma는 사업에 초점을 맞추는 표준 조직이라고 스스로를 정의한다. Ecma는 표준 개발 시간을 최소화하기 위해 관료적인 과정을 최소화한다. 국제 표준 기구(International Standards Organization)는 Ecma를 인정하기에 Ecma 표준은 ISO 표준이 되기 위한 패스트트랙 과정을 사용할 수 있다. 그리고 카길의 연결뿐만 아니라 선(Sun)또한 Ecma 회원이었다. 그리고 마이크로소프트의 이의에도 불구하고 윈도우 API 표준을 발행한 것으로 Ecma의 독립성이 입증되었다고 Sun에서는 간주했다. [LaMonica 1995]

1996년 봄과 여름 동안 넷스케이프, 썬, 그리고 얀 반 덴 벨드 간의 비공식적인 접촉과 논의가 이루어졌다. 9월에 Ecma 조정[^31] 위원회(1996b)는 넷스케이프의 Javascript 표준화 활동 시작 요청을 고려하여 1996년 11월 4-5일 실리콘 밸리에서 프로젝트 개시 회의를 개최하기로 결정했다. 넷스케이프는 공식적으로 Ecma 준회원[^32] 멤버십을 신청했다[Sampath 1996]. 10월 30일에는 "자바스크립트 프로젝트 개시 회의"에 대한 공개 초대장 [Ecma International 1996a]이 발행되었다. 만약 그게 충분한 관심을 받으면 새로운 Ecma 기술 위원회가 조직될 예정이었다. Ecma는 소속된 기술 위원회들에 숫자 번호를 붙이는데, 사용 가능한 다음 번호는 39였다. 1996년 12월 Ecma 총회는 반기 회의에서 TC39 창설과 업무 기술서 제작을 승인했다. 동시에 마이크로소프트가 일반 회원으로 Ecma에 가입했다.

# 8. 첫 TC39 회의(The First TC39 meeting)

TC39를 조직하는 회의는 1996년 11월 21-22일 캘리포니아 마운틴뷰의 넷스케이프 사무실에서 열렸다. 회의록 [TC39 1996]에 따르면 참석자는 총 30명이었다(그림 11). 회의는 Ecma를 대표하여 참석한 Jan van den Beld와 넷스케이프의 코어 기술 부사장인 David Stryker의 환영사로 시작되었다. Stryker는 위원회가 당시의 구현에서 최소한의 변화만 있는 명세를 만들기를 희망하며 그 이상의 언어 확장은 미래로 미루어지길 바란다고 했다. 

![그림 11](./pictures/figure11.png)

마이크로소프트 인터넷 익스플로러 개발팀 리더 Thomas Reardon은 위원회가 HTML 객체 모델에 대한 내장 라이브러리 작업을 W3C에 맡기는 것이 좋다고 권했다. 작업 중복을 피하기 위해서였다. 위원회는 이 권고를 받아들였다. 이는 위원회의 초기 성공에 핵심적인 역할을 했다. 넷스케이프와 마이크로소프트의 핵심 언어 기능은 매우 유사했지만 HTML API는 크게 달랐기 때문이다. TC39가 오직 플랫폼/호스트 환경에 독립적인 표준만 개발하기로 한 결정은 일관적인 TC39의 핵심 운영 원칙 중 하나가 되었다. Reardon은 마이크로소프트가 JScript를 넷스케이프와 완전히 호환되도록 하기 위해 겪었던 어려움들을 이야기하며 언어 명세의 공식화 필요성을 강하게 주장했다. 하지만 경쟁 구현체들이 가치를 더할 수 있는 여지를 남겨두어야 한다고도 이야기했다.

제안된 의제에는 먼저 넷스케이프, 선, 마이크로소프트, Nombas Inc.의 기술 발표가 있었다. 그뿐만 아니라 새로운 Ecma 기술 위원회를 설립하고 표준 언어 명세를 작성하는 작업을 시작하는 데 필요한 실제 조직 활동도 의제에 있었다. 그러나 회의에서 선은 아무것도 발표할 필요가 없다고 말했고, Borland International의 발표가 추가로 포함되었다.

넷스케이프와 불랜드는 회의가 시작할 때 기술 명세의 초안을 배포하였다. 마이크로소프트는 그렇지 않았다. Thomas Reardon의 발표 중에, 마이크로소프트가 자체적으로 초안 명세를 개발했다며 문서를 들어 보였다. Reardon은 아직 복사본을 준비하지 못했지만 다음 날 복사본을 제공할 것이라고 주장했으므로, 마이크로소프트의 기술 발표는 회의 둘째 날로 이동되었다.

넷스케이프와 Borland는 회의 시작 시 기술 명세 초안을 배포했다. 마이크로소프트는 그러지 않았다. Thomas Reardon이 발표 중에 마이크로소프트가 초안 명세를 개발했다고 언급하며 문서를 들어 보였다. Reardon은 아직 시간이 부족해서 복사본을 준비하지 못했고 다음 날 복사본을 제공할 거라고 했다. 그래서 마이크로소프트의 기술 발표는 회의 둘째 날로 미뤄졌다.

Brendan Eich도 그 자리에 참석했지만, 넷스케이프의 기술 발표는 Anh Nguyen이 진행했다. 그 발표에서는 Eich와 C. Rand McKinny가 작성한 JavaScript 1.1의 JavaScript 언어 명세 초안을 소개했다 [1996]. 넷스케이프는 이를 Ecma에 기여하여 표준화 노력의 기초 문서 중 하나가 되도록 했다. Nguyen은 넷스케이프 Navigator 3의 JavaScript 1.1이 넷스케이프 2의 초기 JavaScript 버전과 몇 가지 차이가 있다고 설명했다. 넷스케이프의 명세는 ANSI C 언어 표준 [ANSI X3 1989]에서 사용된 것과 유사한 BNF 표기법을 사용하여 언어 구문을 기술했다. 대부분의 시맨틱을 비공식적인 산문체로 썼고 언어의 강제 형변환 규칙을 기술하기 위해서는 표 형식을 사용했다.

볼랜드는 Javascript의 서버 구현과 Javascript IDE를 만들었다[Lazar 1997]. 볼랜드의 발표는 그들이 이미 구현했거나 구현할 예정인 여러가지 확장들에 중점을 두었다[Borland International 1996]. 그들의 주요 확장은 클래스 정의, try/catch/finally 예외 처리, C 언어 스타일 switch 문, 코드 블록을 일급 값으로 사용하기, 배열 리터럴, C 언어 스타일 전처리기, 그리고 내장 라이브러리에 추가된 몇 가지 I/O 기능 등이었다. 볼랜드도 넷스케이프의 구현과 호환성을 갖도록 하기 위해 겪었던 어려움을 강조하며 상호 호환 가능한 구현을 위해 더 공식적인 명세가 필요하다고 말했다.

Nombas Inc.의 Brent Noorda는 Nombas Inc.가 Cmm("C minus minus")을 스크립팅 언어로 시장에 출시한 경험에 대해 발표했다. Cmm의 표면적인 문법과 몇몇 시맨틱은 Javascript 1.0과 상당히 비슷했다. Nombas는 이후 Cmm 구현을 임베디드 애플리케이션용 ECMAScript 구현으로 발전시켰다[Noorda 2012].

회의 첫 날이 끝나자마자, 마이크로소프트의 Robert Welland는 할 일이 있었다 [Welland et al. 2018, at +8:30]. Thomas Reardon이 발표에서 복사본을 만들 시간이 없었다고 주장한 건 Welland에게 마이크로소프트 명세 작업에 더 많은 시간을 주기 위한 지연 전술이었다. 회의를 위해 명세 문서를 작성하는 건 마이크로소프트의 테크니컬 라이터에게 맡겨졌었다. 그런데 Welland는 회의에 참석하기 직전 이 문서를 받았을 때 그 문서가 초기 언어 명세로조차 부적합하다고 판단했다. 그는 그 문서를 위원회에 제출하고 싶지 않았다. 하지만 그가 회의 시작 전 넷스케이프의 문서를 보았을 때 Welland는 넷스케이프가 작성한 문서도 언어 명세로 부족하다고 느꼈다. 그는 넷스케이프의 문서가 표준 개발을 위한 유일한 기초 문서가 되는 것을 원하지 않았다. 그래서 Welland와 Reardon은 하루를 지연시켜서 더 나은 문서를 준비하고 회의 둘째 날이 시작할 때 제시하기로 결정했다.

회의가 끝난 후 Robert Welland는 Walter Smith의 집을 방문했다. Walter Smith는 마이크로소프트에서 일하고 있었지만 여전히 Bay Area에 거주하고 있는, Welland와 NewtonScript 작업을 함께했던 동료였다. 그들은 밤새도록 마이크로소프트의 문서를 핵심 Javascript 언어의 그럴듯한 초기 명세로 바꾸는 작업을 했다. 그들의 명세는 ANSI C 표준의 많은 문법을 빌려왔고 형변환 규칙에 표를 사용했다. 하지만 Welland는 나머지 시맨틱이 더 형식적으로 명시되기를 원했다. 그는 LISP 1.5 Programmer’s Manual[McCarthy and Levin 1965]이 Lisp 인터프리터의 시맨틱을 설명할 때 먼저 해당 문법이 어떻게 평가되어야 하는지를 엄밀하게 기술하고 그 문법적 형태가 바로 따라 나오는 방식을 쓴 것을 기억해냈다 [Welland et al. 2018, at +10:10]. 어떤 경우 시맨틱은 의사코드를 사용하여 제시되었다[^33]. Welland는 Javascript의 평가 시맨틱을 설명하기 위해 단계별로 번호가 매겨진 비슷한 스타일의 의사코드를 사용하기로 결정했다.

Welland와 Smith는 당시의 JScript 구현을 바탕으로 문서에 의미론을 추가했다. 확신이 서지 않는 부분이 있으면 그들의 Self와 NewtonScript 경험으로 돌아가서, 그 관점에서 보고 타당한 것들을 기술했다. 문서에는 Array의 객체 다이어그램도 있었는데 이것은 매우 Self와 비슷한 방식으로 속성 상속을 모델링했다. 다음날 아침까지 그들은 출발점으로 사용하기에는 충분히 좋다고 느껴지는 문서를 만들었다. 그들은 문서를 복사했고 Welland는 회의 둘째날이 시작할 때 그것을 배포했다. 그 문서의 제목은 "The JScript Language Specification, Version 0.1 [Welland et al. 1996]"이었고, Ecma의 표 대한 마이크로소프트의 기초 문서 기여가 되었다.

회의 참석자들은 Welland의 문서를 일반적으로 좋아했고 상호 호환이 가능한 구현을 보장하기 위해서는 더 형식적인 명세가 필요하다는 데에 동의했다. 그리고 Robert Welland는 발표를 하면서 이 사실에 기뻐했다. 하지만 아직 없는 공식 명세를 기다리는 쪽으로 합의되지는 않았다. 대신 넷스케이프, 마이크로소프트, 볼랜드가 기여한 명세들을 통합하여 표준의 초기 초안을 만들고 그 초안을 더 완전하고 정확하게 만드는 작업을 하는 쪽으로 합의되었다. 그 첫번째 단계로 위원회는 표준의 첫 번째 버전에서 해결하거나 명확히 해야 할 사항들의 목록 [부록 G]을 생성했다. 기초 문서 제출이 2개 있었기 때문에 어떤 문서에서 편집을 시작할지 둘 중 하나를 골라야 했다. 넷스케이프의 문서는 FrameMaker를 사용하여 작성되었고, 마이크로소프트의 문서는 Word를 사용하여 작성되었다. Ecma 대표들은 그들의 내부 편집 과정이 Word를 사용한다고 설명하며 위원회에서 마이크로소프트의 기여를 기초 문서로 사용하기로 합의했다. Welland는 이 사실에 놀랐다.

> Chairman: Mr. G. Robinson (Sun)
> Vice-Chairman: Mr. C. Cargill (Netscape)
> Vice-Chairman: Mr. S. Wiltamuth (Microsoft)
> Principal editor: Mr. M. Gardner (Borland) (to be confirmed)
> Assistant editor: Mr. A. Murarka (Spyglass) (to be confirmed)
>
> Fig. 12. Officers Elected at First TC39 Meeting [TC39 1996]

위원회는 초기 임원진(그림 12)을 선출하고 매우 공격적인 목표를 설정했다. 1997년 1월 다음 회의까지 첫 번째 초안 작성, 1997년 4월 최종 초안 작성 후 1997년 6월의 Ecma 총회에서 표준 승인을 목표로 했다. 위원회는 약 6주 간격으로 다음 회의 일정을 잡고 사설 메일링 리스트와 ftp 서버를 설정하기 위한 조치를 시작했다[^34].

TC39의 두 번째 회의 [1997e]는 1997년 1월 14일과 15일에 열렸다. 회의에는 Ecma 회원이 아닌 5명의 게스트를 포함해서 22명이 참석했다. Jan van den Beld는 Ecma 총회에서 TC39의 설립이 확정되었다고 발표했다. 그는 TC39가 가능한 한 빨리 Ecma의 회원 자격과 참여에 관한 규칙을 따르기 시작해야 한다고 강조했다. Ecma 표준의 개발에 기여하는 자들은 Ecma 회원인 기관의 대표들이어야 한다고 말이다.

회의에서 다루어진 주요한 기술 사안은 표준의 첫번째 초안[TC39 1997c]의 검토와 토의였다. Borland의 Michael Gardner와 Randy Solton은 Netscape, Microsoft, Borland의 기여를 통합하여 문서를 만들었다. Spyglass는 Ecma에 가입하지 않았기 때문에 Anup Murarka는 첫 번째 초안 개발에 참여하지 않았다. 세 가지 구현에서 완전히 동일한 기능은 논쟁의 여지가 없는 것으로 간주했다. 그리고 구현 간에 기능이 달랐던 부분은 조정되어야 하는 것으로 분류했다.

특정 구현에만 있었던 기능은 "제안된 확장" 부록에 정리되었다. 위원회는 어떻게 확장들을 처리할지 논의했다. 그 결과 확장보다는 모든 당시의 구현에서 공통적이었던 핵심 기능들을 구현하는 것을 우선시하기로 합의했다. 그리고 명세는 기존 애플리케이션을 수정해야 하도록 만드는 변경사항(역주: 즉 breaking change)을 피해야 한다는 합의도 있었다. 이는 표준의 모든 후속 개정들에서도 중요한 설계 지침이 되었다.

촉박한 일정을 맞추기 위해 위원회는 편집자들과 함께 명세의 빠진 부분을 보충하고 중요한 기술적 이슈를 고치는 작업을 할 즉석의 기술 작업 그룹(ad hoc technical working group)을 만들었다. 이 그룹은 전자상으로 소통하고 한 주는 대면 회의, 한 주는 원격 회의로 번갈아가면서 주간 회의를 진행하기로 했다. Scott Wiltamuth가 조사 위원으로 활동할 예정이었다. TC39 회의는 1월 15일 오전 10시 30분에 끝났고 나머지 시간은 즉석 기술 작업 그룹의 회의에 사용되었다.

회의 이후 Borland는 Ecma에 가입하지 않기로 결정했다. 그래서 Michael Gardner는 편집자로 계속 활동할 수 없었다. Sun은 Guy Steele을 보냈고 그는 1997년 1월 말부터 표준의 첫 번째 판이 나오는 1997년 9월 초까지 편집자로 활동했다.

# 9. 명세를 향한 여정(Crafting the Specification)

Michael Gardner와 Randy Solton은 11월 회의 직후 첫번째 명세 초안의 작업을 시작했다. 그리고 이후 6주간 놀라운 진전을 이뤘다. Gardner와 Solton 외에도 첫번째 초안에는 다음과 같은 기술 기여자들이 적혀 있다. Brendan Eich(넷스케이프), C. Rand McKinney(넷스케이프), Donna Converse(넷스케이프), Shon Katzenberger(마이크로소프트), Robert Welland (마이크로소프트).

Robert Welland는 Redmond로 돌아가서 자신이 만든 JScript 0.1 명세를 Shon Katzenberger에게 맡겨 계속 개발하도록 하였다 [Welland et al. 2018, at 12:02]. 수학 박사였던 Katzenberger는 형식적인 표기법에 익숙했고, Javascript 시맨틱을 기술하는 데에 의사 코드 개념(부록 P)이 잘 맞다고 판단했다. 의사 코드는 Katzenberger가 생각하기에 상호 호환성을 보장할 만큼의 충분한 세부사항을 제공했다. Katzenberger는 표준 개발에 있어서 마이크로소프트의 주요한 기술 기여자가 되었다. Katzenberger는 Welland와 Smith가 늦은 밤 작업한 것을 실행 중인 구현과 비교 검토하고, 그들이 다루지 않았던 부분들에 대한 추가적인 의사 코드 알고리즘을 작성하여 확장하였다. 그 다음 그렇게 새로 수정된 자료를 공식 초안에 포함시키기 위해 Borland 편집자들에게 전달하였다. 2018년 인터뷰에서 Katzenberger [Welland et al. 2018, at 21:16]는 명세 편집 과정에서 종종 자신의 알고리즘이 의도치 않게 망가졌다는 사실에 불만이 있었다고 회상했다. Guy Steele이 편집자로 활동하게 되자 그는 매우 만족했다.

1997년 1월 10일의 초안 [TC39 1997c]은 명세의 기본 구조(그림 13)를 확립하였다. 그리고 언어의 정의에 사용된 많은 기본적인 기술과 관례와 용어를 정의했다. 이때 만들어진 많은 부분은 20년이 지난 지금의 ECMAScript 표준에서도 여전히 사용되고 있다.

문법 규칙에 대한 설명은 대부분 넷스케이프가 작성한 사양에서 가져온 것이다. 하지만 표현식과 문장 문법의 구조와 생성 규칙은 대부분 마이크로소프트가 작성한 사양에서 사용된 것을 따랐다. 표현식 문법은 두 가지 기여 사항과 모두 달랐는데 함수 호출의 우선순위, 객체 생성(new 연산자), 객체 속성 접근 표현식 등의 세부 사항에서 차이가 있었다.

당시 초안은 자동 세미콜론 삽입(ASI)의 규칙을 파싱 과정의 에러 수정 과정으로 정확하게 정의하려고 시도한다. 문장 문법은 복합 문장이 아닌 문장에 대해서 문장 종결을 위한 세미콜론을 요구한다. 따라서 자동 세미콜론 삽입이 없으면 세미콜론을 빼먹을 시 구문 오류가 발생한다. ASI 명세는 Javascript 파서가 세미콜론이 있다고 가정하고 파싱을 다시 함으로써 구문 오류를 수정해야 할 때가 언제인지를 정의한다. 첫 번째 초안의 ASI 규칙은 불완전했고 이후의 초안과 ECMAScript 명세 판본에서 다시 정의되었다.

![그림 14](./pictures/figure14.png)

1월 10일의 초안에는 그림 14에서 볼 수 있는 것과 같은 Shon Katzenberger의 의사코드 알고리즘들이 포함되어 있다. 이 알고리즘은 여러 언어 구조의 시맨틱을 정의하기 위해서 사용되었다.알고리즘들은 순차적으로 번호가 매겨진 단계들과 그 단계들 간에 간단한 조건부 제어 흐름으로 구성되어 있다. 각 단계는 명령적인 산문형 문장으로 구성되어 있다. 각 단계를 서술하는 문장들은 자주 발생하는 동작들에 대해서 명세가 정의한 어휘들을 포함한 영어로 작성되었다. 알고리즘은 이름이 지정될 수 있고 명세의 다른 알고리즘에서 "호출"될 수 있다.

이 초안은 또한 알고리즘에서 사용되는 자료형을 정의한다. Number, Boolean, String, Object, Undefined, Null은 ECMAScript 프로그램에서 보이는 값의 종류들이다. Reference, Completion, List 유형의 값은 언어 시맨틱을 정의하는 데 사용되며 ECMAScript 프로그램에 직접적으로 포함되어 있지는 않다.

객체 자료형의 명세는 개별 속성이 어떻게 접근되고 수정되는지를 제어하는 속성 어트리뷰트<sup>g</sup>(attribute)의 개념을 소개한다. 그리고 7가지 어트리뷰트를 정의한다. 그것들은 ReadOnly, ErrorOnWrite, DontEnum, NotImplicit, NotExplicit, Permanent, Internal로 총 7가지였다. 최종적으로는 ErrorOnWrite, NotImplicit, NotExplicit은 제거되었고 Permanent는 DontDelete로 이름이 변경되었다. 객체 속성들은 이런 각각의 내부 속성들을 가지고 있는데 이런 내부 속성들은 ECMAScript 프로그램에서 직접 드러나 있지는 않다. 하지만 이런 내부 속성들(internal properties<sup>g</sup>)는 객체 시맨틱이나 내장 및 호스트 객체의 고유한 동작을 구현하는 데에 필요한 상태를 유지하는 데에 사용된다.

내부 메서드<sup>g</sup> 개념도 도입되었다. 이는 객체의 필수적인 동작들을 정의하는 알고리즘이다. 다양한 종류의 객체들(예를 들어 Array 객체)은 몇몇 내부 메서드를 다르게 정의함으로써 동작의 다양성을 제공할 수 있다. 내부 메서드의 인터페이스는 기본적으로 간단한 메타오브젝트 프로토콜<sup>g</sup>  사양이다 [Kiczales et al. 1991].

명세에서 내부 메소드와 내부 속성은 `[[Foo]]`와 같이 이중 괄호로 둘러싸인 이름을 가진다. 1월 10일 초안은 내부 메소드 `[[Get]]`, `[[Put]]`, `[[HasProperty]]`, `[[Construct]]`, `[[Call]]`과 내부 속성 `[[Prototype]]`을 정의하였다. 이러한 내부 메소드들은 객체 속성 접근, 프로토타입 상속, 그리고 함수 호출의 시맨틱을 처음으로 형식적으로 표현하는 데 사용되었다. ES1이 완성될 때에는 `[[CanPut]]`과 `[[Delete]]` 내부 메소드가 추가되었다.

첫 번째 초안의 목차에는 네이티브(내장된) ECMAScript 객체들과 브라우저 및 웹 서버 호스팅 환경에서 제공되는 객체들에 대한 섹션이 포함되어 있었다. 하지만 이 섹션들은 1월 10일 초안에서는 비어 있었다. 초안 내에서 'Issue'라고 명시적으로 태그된 항목이 스무 개 있었다. 이들은 부록에서 설명하는 언어 확장 외에 추가적인 것들이었다.

![그림 15](./pictures/figure15.png)

1월 10일 초안은 1997년 1월 15일에 열린 첫 번째 기술 작업 그룹 회의의 논의 기반으로 사용되었다. 여기서는 여러 중요한 결정들이 내려졌는데 [Wiltamuth 1997a] 다음과 같은 내용을 포함한다.

- 첫 번째 표준은 브라우저나 웹 서버와 같은 호스트 환경에서 제공하는 라이브러리 객체와 함수들에 대한 명세는 제공하지 않는다. 
- 현재 언어의 확장은 먼저 완전한 초안 명세가 만들어진 후에 고려한다.
- 쉼표와 `?`연산자는 참조값을 전파하지 않는다. 따라서 이들은 할당문의 왼쪽에 쓰일 수 없고 함수 호출에 `this`값을 제공하지 않는다.
- 아스키 코드가 아닌 유니코드 문자는 식별자에 사용하는 것을 허용하지 않는다.
- NUL (U+0000)문자는 문자열 값으로 허용된다.
- 전역 함수와 변수 선언은 enumerable, deletable한 속성을 만든다. 명세에서는 내장 객체의 속성들을 기본적으로 enumerable하지 않고 deletable하지도 않다고 정의한다.

첫번째 작업 그룹 회의에서 해결되지 않은 미해결 이슈는 다중 할당의 평가 순서, 상속된 읽기 전용 속성에 대한 할당의 시맨틱, 1970년 이전의 날짜 값을 어떻게 수용할지 등이 있었다.
